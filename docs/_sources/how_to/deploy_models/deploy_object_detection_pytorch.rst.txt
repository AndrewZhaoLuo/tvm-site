
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "how_to/deploy_models/deploy_object_detection_pytorch.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_how_to_deploy_models_deploy_object_detection_pytorch.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_how_to_deploy_models_deploy_object_detection_pytorch.py:


Compile PyTorch Object Detection Models
=======================================
This article is an introductory tutorial to deploy PyTorch object
detection models with Relay VM.

For us to begin with, PyTorch should be installed.
TorchVision is also required since we will be using it as our model zoo.

A quick solution is to install via pip

.. code-block:: bash

    pip install torch==1.7.0
    pip install torchvision==0.8.1

or please refer to official site
https://pytorch.org/get-started/locally/

PyTorch versions should be backwards compatible but should be used
with the proper TorchVision version.

Currently, TVM supports PyTorch 1.7 and 1.4. Other versions may
be unstable.

.. GENERATED FROM PYTHON SOURCE LINES 42-57

.. code-block:: default



    import tvm
    from tvm import relay
    from tvm import relay
    from tvm.runtime.vm import VirtualMachine
    from tvm.contrib.download import download_testdata

    import numpy as np
    import cv2

    # PyTorch imports
    import torch
    import torchvision








.. GENERATED FROM PYTHON SOURCE LINES 63-65

Load pre-trained maskrcnn from torchvision and do tracing
---------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 65-102

.. code-block:: default

    in_size = 300

    input_shape = (1, 3, in_size, in_size)


    def do_trace(model, inp):
        model_trace = torch.jit.trace(model, inp)
        model_trace.eval()
        return model_trace


    def dict_to_tuple(out_dict):
        if "masks" in out_dict.keys():
            return out_dict["boxes"], out_dict["scores"], out_dict["labels"], out_dict["masks"]
        return out_dict["boxes"], out_dict["scores"], out_dict["labels"]


    class TraceWrapper(torch.nn.Module):
        def __init__(self, model):
            super().__init__()
            self.model = model

        def forward(self, inp):
            out = self.model(inp)
            return dict_to_tuple(out[0])


    model_func = torchvision.models.detection.maskrcnn_resnet50_fpn
    model = TraceWrapper(model_func(pretrained=True))

    model.eval()
    inp = torch.Tensor(np.random.uniform(0.0, 250.0, size=(1, 3, in_size, in_size)))

    with torch.no_grad():
        out = model(inp)
        script_module = do_trace(model, inp)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading: "https://download.pytorch.org/models/maskrcnn_resnet50_fpn_coco-bf2d0c1e.pth" to /workspace/.cache/torch/hub/checkpoints/maskrcnn_resnet50_fpn_coco-bf2d0c1e.pth
      0%|          | 0.00/170M [00:00<?, ?B/s]      2%|2         | 4.01M/170M [00:00<00:04, 41.0MB/s]      5%|4         | 7.95M/170M [00:00<00:04, 40.9MB/s]      7%|6         | 11.9M/170M [00:00<00:04, 35.0MB/s]      9%|9         | 16.0M/170M [00:00<00:04, 38.0MB/s]     12%|#1        | 19.7M/170M [00:00<00:04, 32.9MB/s]     14%|#4        | 24.3M/170M [00:00<00:04, 36.5MB/s]     16%|#6        | 27.9M/170M [00:00<00:04, 36.3MB/s]     19%|#8        | 31.5M/170M [00:00<00:04, 36.1MB/s]     21%|##        | 35.6M/170M [00:01<00:03, 37.9MB/s]     23%|##3       | 39.2M/170M [00:01<00:04, 31.5MB/s]     25%|##4       | 42.4M/170M [00:01<00:04, 30.4MB/s]     27%|##6       | 45.5M/170M [00:01<00:04, 27.0MB/s]     28%|##8       | 48.2M/170M [00:01<00:05, 25.2MB/s]     30%|###       | 51.3M/170M [00:01<00:04, 27.1MB/s]     32%|###1      | 54.0M/170M [00:01<00:05, 22.6MB/s]     34%|###3      | 57.4M/170M [00:01<00:04, 25.1MB/s]     36%|###5      | 60.5M/170M [00:02<00:04, 27.0MB/s]     37%|###7      | 63.3M/170M [00:02<00:04, 24.3MB/s]     39%|###8      | 65.8M/170M [00:02<00:04, 23.9MB/s]     40%|####      | 68.1M/170M [00:02<00:04, 21.6MB/s]     41%|####1     | 70.3M/170M [00:02<00:04, 21.6MB/s]     43%|####2     | 72.4M/170M [00:02<00:04, 21.7MB/s]     44%|####4     | 74.8M/170M [00:02<00:04, 22.5MB/s]     45%|####5     | 77.0M/170M [00:02<00:04, 21.6MB/s]     47%|####6     | 79.2M/170M [00:03<00:04, 21.8MB/s]     48%|####7     | 81.4M/170M [00:03<00:04, 22.0MB/s]     49%|####9     | 83.6M/170M [00:03<00:04, 22.3MB/s]     50%|#####     | 85.8M/170M [00:03<00:04, 20.9MB/s]     52%|#####1    | 88.0M/170M [00:03<00:03, 21.7MB/s]     53%|#####3    | 90.3M/170M [00:03<00:03, 22.2MB/s]     54%|#####4    | 92.4M/170M [00:03<00:03, 22.0MB/s]     56%|#####5    | 94.8M/170M [00:03<00:03, 22.7MB/s]     57%|#####7    | 97.0M/170M [00:03<00:03, 23.0MB/s]     60%|#####9    | 102M/170M [00:03<00:02, 30.1MB/s]      62%|######2   | 106M/170M [00:04<00:02, 31.2MB/s]     65%|######4   | 110M/170M [00:04<00:01, 35.3MB/s]     67%|######7   | 115M/170M [00:04<00:01, 38.0MB/s]     70%|#######   | 119M/170M [00:04<00:01, 41.7MB/s]     73%|#######2  | 124M/170M [00:04<00:01, 36.7MB/s]     75%|#######4  | 127M/170M [00:04<00:01, 36.2MB/s]     77%|#######7  | 132M/170M [00:04<00:01, 39.1MB/s]     80%|#######9  | 136M/170M [00:04<00:00, 39.9MB/s]     82%|########2 | 140M/170M [00:04<00:00, 37.3MB/s]     84%|########4 | 143M/170M [00:05<00:01, 24.5MB/s]     86%|########6 | 146M/170M [00:05<00:01, 23.4MB/s]     88%|########7 | 149M/170M [00:05<00:01, 20.7MB/s]     89%|########9 | 151M/170M [00:05<00:00, 21.9MB/s]     92%|#########1| 155M/170M [00:05<00:00, 26.7MB/s]     93%|#########3| 158M/170M [00:05<00:00, 27.5MB/s]     95%|#########5| 162M/170M [00:06<00:00, 29.4MB/s]     98%|#########8| 166M/170M [00:06<00:00, 35.0MB/s]    100%|##########| 170M/170M [00:06<00:00, 28.8MB/s]
    /usr/local/lib/python3.7/dist-packages/torch/nn/functional.py:3878: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      for i in range(dim)
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/anchor_utils.py:127: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
      for g in grid_sizes
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/anchor_utils.py:127: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      for g in grid_sizes
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/rpn.py:73: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
      A = Ax4 // 4
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/rpn.py:74: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
      C = AxC // A
    /usr/local/lib/python3.7/dist-packages/torchvision/ops/boxes.py:156: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      boxes_x = torch.min(boxes_x, torch.tensor(width, dtype=boxes.dtype, device=boxes.device))
    /usr/local/lib/python3.7/dist-packages/torchvision/ops/boxes.py:158: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      boxes_y = torch.min(boxes_y, torch.tensor(height, dtype=boxes.dtype, device=boxes.device))
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/transform.py:293: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      for s, s_orig in zip(new_size, original_size)
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/roi_heads.py:387: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      return torch.tensor(M + 2 * padding).to(torch.float32) / torch.tensor(M).to(torch.float32)




.. GENERATED FROM PYTHON SOURCE LINES 103-105

Download a test image and pre-process
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 105-116

.. code-block:: default

    img_url = (
        "https://raw.githubusercontent.com/dmlc/web-data/master/gluoncv/detection/street_small.jpg"
    )
    img_path = download_testdata(img_url, "test_street_small.jpg", module="data")

    img = cv2.imread(img_path).astype("float32")
    img = cv2.resize(img, (in_size, in_size))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = np.transpose(img / 255.0, [2, 0, 1])
    img = np.expand_dims(img, axis=0)








.. GENERATED FROM PYTHON SOURCE LINES 117-119

Import the graph to Relay
-------------------------

.. GENERATED FROM PYTHON SOURCE LINES 119-123

.. code-block:: default

    input_name = "input0"
    shape_list = [(input_name, input_shape)]
    mod, params = relay.frontend.from_pytorch(script_module, shape_list)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /workspace/python/tvm/relay/build_module.py:348: DeprecationWarning: Please use input parameter mod (tvm.IRModule) instead of deprecated parameter mod (tvm.relay.function.Function)
      DeprecationWarning,
    /workspace/python/tvm/relay/frontend/pytorch.py:430: DeprecationWarning: `np.int` is a deprecated alias for the builtin `int`. To silence this warning, use `int` by itself. Doing this will not modify any behavior and is safe. When replacing `np.int`, you may wish to use e.g. `np.int64` or `np.int32` to specify the precision. If you wish to review your current use, check the release note link for additional information.
    Deprecated in NumPy 1.20; for more details and guidance: https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations
      inputs[3], lambda ret: ret.astype(np.int).item(0)




.. GENERATED FROM PYTHON SOURCE LINES 124-130

Compile with Relay VM
---------------------
Note: Currently only CPU target is supported. For x86 target, it is
highly recommended to build TVM with Intel MKL and Intel OpenMP to get
best performance, due to the existence of large dense operator in
torchvision rcnn models.

.. GENERATED FROM PYTHON SOURCE LINES 130-139

.. code-block:: default


    # Add "-libs=mkl" to get best performance on x86 target.
    # For x86 machine supports AVX512, the complete target is
    # "llvm -mcpu=skylake-avx512 -libs=mkl"
    target = "llvm"

    with tvm.transform.PassContext(opt_level=3, disabled_pass=["FoldScaleAxis"]):
        vm_exec = relay.vm.compile(mod, target=target, params=params)








.. GENERATED FROM PYTHON SOURCE LINES 140-142

Inference with Relay VM
-----------------------

.. GENERATED FROM PYTHON SOURCE LINES 142-147

.. code-block:: default

    dev = tvm.cpu()
    vm = VirtualMachine(vm_exec, dev)
    vm.set_input("main", **{input_name: img})
    tvm_res = vm.run()








.. GENERATED FROM PYTHON SOURCE LINES 148-150

Get boxes with score larger than 0.9
------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 150-160

.. code-block:: default

    score_threshold = 0.9
    boxes = tvm_res[0].numpy().tolist()
    valid_boxes = []
    for i, score in enumerate(tvm_res[1].numpy().tolist()):
        if score > score_threshold:
            valid_boxes.append(boxes[i])
        else:
            break

    print("Get {} valid boxes".format(len(valid_boxes)))




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Get 9 valid boxes





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  59.831 seconds)


.. _sphx_glr_download_how_to_deploy_models_deploy_object_detection_pytorch.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: deploy_object_detection_pytorch.py <deploy_object_detection_pytorch.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: deploy_object_detection_pytorch.ipynb <deploy_object_detection_pytorch.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
