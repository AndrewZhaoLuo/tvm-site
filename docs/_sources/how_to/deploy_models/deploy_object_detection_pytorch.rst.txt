.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_how_to_deploy_models_deploy_object_detection_pytorch.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_how_to_deploy_models_deploy_object_detection_pytorch.py:


Compile PyTorch Object Detection Models
=======================================
This article is an introductory tutorial to deploy PyTorch object
detection models with Relay VM.

For us to begin with, PyTorch should be installed.
TorchVision is also required since we will be using it as our model zoo.

A quick solution is to install via pip

.. code-block:: bash

    pip install torch==1.7.0
    pip install torchvision==0.8.1

or please refer to official site
https://pytorch.org/get-started/locally/

PyTorch versions should be backwards compatible but should be used
with the proper TorchVision version.

Currently, TVM supports PyTorch 1.7 and 1.4. Other versions may
be unstable.


.. code-block:: default


    import tvm
    from tvm import relay
    from tvm import relay
    from tvm.runtime.vm import VirtualMachine
    from tvm.contrib.download import download_testdata

    import numpy as np
    import cv2

    # PyTorch imports
    import torch
    import torchvision







Load pre-trained maskrcnn from torchvision and do tracing
---------------------------------------------------------


.. code-block:: default

    in_size = 300

    input_shape = (1, 3, in_size, in_size)


    def do_trace(model, inp):
        model_trace = torch.jit.trace(model, inp)
        model_trace.eval()
        return model_trace


    def dict_to_tuple(out_dict):
        if "masks" in out_dict.keys():
            return out_dict["boxes"], out_dict["scores"], out_dict["labels"], out_dict["masks"]
        return out_dict["boxes"], out_dict["scores"], out_dict["labels"]


    class TraceWrapper(torch.nn.Module):
        def __init__(self, model):
            super().__init__()
            self.model = model

        def forward(self, inp):
            out = self.model(inp)
            return dict_to_tuple(out[0])


    model_func = torchvision.models.detection.maskrcnn_resnet50_fpn
    model = TraceWrapper(model_func(pretrained=True))

    model.eval()
    inp = torch.Tensor(np.random.uniform(0.0, 250.0, size=(1, 3, in_size, in_size)))

    with torch.no_grad():
        out = model(inp)
        script_module = do_trace(model, inp)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Downloading: "https://download.pytorch.org/models/maskrcnn_resnet50_fpn_coco-bf2d0c1e.pth" to /workspace/.cache/torch/hub/checkpoints/maskrcnn_resnet50_fpn_coco-bf2d0c1e.pth
      0%|          | 0.00/170M [00:00<?, ?B/s]      2%|1         | 2.75M/170M [00:00<00:06, 28.5MB/s]      3%|3         | 5.48M/170M [00:00<00:07, 23.3MB/s]      5%|4         | 8.00M/170M [00:00<00:06, 24.4MB/s]      8%|7         | 13.2M/170M [00:00<00:04, 35.4MB/s]     10%|9         | 16.7M/170M [00:00<00:04, 34.8MB/s]     12%|#1        | 20.1M/170M [00:00<00:05, 27.2MB/s]     14%|#3        | 22.9M/170M [00:00<00:05, 25.7MB/s]     15%|#5        | 25.6M/170M [00:00<00:05, 25.3MB/s]     17%|#7        | 28.9M/170M [00:01<00:05, 27.8MB/s]     20%|##        | 34.1M/170M [00:01<00:04, 35.0MB/s]     22%|##2       | 37.6M/170M [00:01<00:04, 32.8MB/s]     25%|##4       | 42.1M/170M [00:01<00:03, 36.1MB/s]     27%|##6       | 45.7M/170M [00:01<00:03, 35.6MB/s]     29%|##8       | 49.2M/170M [00:01<00:03, 32.7MB/s]     31%|###1      | 53.2M/170M [00:01<00:03, 35.1MB/s]     33%|###3      | 56.6M/170M [00:01<00:03, 33.0MB/s]     36%|###5      | 60.4M/170M [00:01<00:03, 34.8MB/s]     38%|###7      | 63.9M/170M [00:02<00:03, 35.3MB/s]     40%|###9      | 67.4M/170M [00:02<00:03, 31.5MB/s]     42%|####1     | 71.2M/170M [00:02<00:03, 33.7MB/s]     44%|####3     | 74.5M/170M [00:02<00:03, 27.7MB/s]     46%|####5     | 78.0M/170M [00:02<00:03, 29.6MB/s]     48%|####7     | 81.0M/170M [00:02<00:03, 25.3MB/s]     50%|#####     | 85.4M/170M [00:02<00:02, 30.2MB/s]     52%|#####2    | 88.6M/170M [00:03<00:02, 30.1MB/s]     54%|#####3    | 91.6M/170M [00:03<00:02, 30.4MB/s]     56%|#####5    | 94.7M/170M [00:03<00:02, 29.5MB/s]     58%|#####8    | 98.5M/170M [00:03<00:02, 32.3MB/s]     60%|#####9    | 102M/170M [00:03<00:02, 32.0MB/s]      62%|######1   | 105M/170M [00:03<00:02, 33.0MB/s]     64%|######3   | 109M/170M [00:03<00:01, 33.5MB/s]     66%|######5   | 112M/170M [00:03<00:01, 32.3MB/s]     68%|######7   | 115M/170M [00:03<00:02, 27.6MB/s]     69%|######9   | 118M/170M [00:04<00:02, 27.1MB/s]     71%|#######   | 120M/170M [00:04<00:02, 25.4MB/s]     72%|#######2  | 123M/170M [00:04<00:01, 25.1MB/s]     74%|#######3  | 125M/170M [00:04<00:02, 21.3MB/s]     75%|#######5  | 127M/170M [00:04<00:02, 18.6MB/s]     76%|#######6  | 130M/170M [00:04<00:02, 19.5MB/s]     77%|#######7  | 132M/170M [00:04<00:02, 18.8MB/s]     80%|#######9  | 135M/170M [00:04<00:01, 22.9MB/s]     81%|########  | 137M/170M [00:05<00:01, 22.6MB/s]     83%|########2 | 140M/170M [00:05<00:01, 25.0MB/s]     85%|########4 | 144M/170M [00:05<00:00, 28.3MB/s]     87%|########6 | 147M/170M [00:05<00:00, 30.2MB/s]     89%|########8 | 150M/170M [00:05<00:00, 27.9MB/s]     90%|######### | 154M/170M [00:05<00:00, 29.1MB/s]     93%|#########3| 158M/170M [00:05<00:00, 33.6MB/s]     95%|#########4| 161M/170M [00:05<00:00, 31.1MB/s]     97%|#########6| 165M/170M [00:05<00:00, 31.0MB/s]     99%|#########8| 168M/170M [00:06<00:00, 32.6MB/s]    100%|##########| 170M/170M [00:06<00:00, 29.3MB/s]
    /usr/local/lib/python3.7/dist-packages/torch/functional.py:445: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at  ../aten/src/ATen/native/TensorShape.cpp:2157.)
      return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
    /usr/local/lib/python3.7/dist-packages/torch/nn/functional.py:3702: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      for i in range(dim)
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/anchor_utils.py:123: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
      torch.tensor(image_size[1] // g[1], dtype=torch.int64, device=device)] for g in grid_sizes]
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/anchor_utils.py:123: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      torch.tensor(image_size[1] // g[1], dtype=torch.int64, device=device)] for g in grid_sizes]
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/rpn.py:84: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
      A = Ax4 // 4
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/rpn.py:85: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
      C = AxC // A
    /usr/local/lib/python3.7/dist-packages/torchvision/ops/boxes.py:146: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      boxes_x = torch.min(boxes_x, torch.tensor(width, dtype=boxes.dtype, device=boxes.device))
    /usr/local/lib/python3.7/dist-packages/torchvision/ops/boxes.py:148: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      boxes_y = torch.min(boxes_y, torch.tensor(height, dtype=boxes.dtype, device=boxes.device))
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/transform.py:276: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      for s, s_orig in zip(new_size, original_size)
    /usr/local/lib/python3.7/dist-packages/torchvision/models/detection/roi_heads.py:372: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
      return torch.tensor(M + 2 * padding).to(torch.float32) / torch.tensor(M).to(torch.float32)
    /usr/local/lib/python3.7/dist-packages/torch/jit/_trace.py:991: TracerWarning: Output nr 2. of the traced function does not match the corresponding output of the Python function. Detailed error:
    Tensor-likes are not close!

    Mismatched elements: 1 / 2 (50.0%)
    Greatest absolute difference: 0.10373502969741821 at index 1 (up to 1e-05 allowed)
    Greatest relative difference: 0.10443917109964881 at index 1 (up to 1e-05 allowed)
      _module_class,



Download a test image and pre-process
-------------------------------------


.. code-block:: default

    img_url = (
        "https://raw.githubusercontent.com/dmlc/web-data/" "master/gluoncv/detection/street_small.jpg"
    )
    img_path = download_testdata(img_url, "test_street_small.jpg", module="data")

    img = cv2.imread(img_path).astype("float32")
    img = cv2.resize(img, (in_size, in_size))
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img = np.transpose(img / 255.0, [2, 0, 1])
    img = np.expand_dims(img, axis=0)







Import the graph to Relay
-------------------------


.. code-block:: default

    input_name = "input0"
    shape_list = [(input_name, input_shape)]
    mod, params = relay.frontend.from_pytorch(script_module, shape_list)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /workspace/python/tvm/relay/build_module.py:439: DeprecationWarning: Please use input parameter mod (tvm.IRModule) instead of deprecated parameter mod (tvm.relay.function.Function)
      DeprecationWarning,



Compile with Relay VM
---------------------
Note: Currently only CPU target is supported. For x86 target, it is
highly recommended to build TVM with Intel MKL and Intel OpenMP to get
best performance, due to the existence of large dense operator in
torchvision rcnn models.


.. code-block:: default


    # Add "-libs=mkl" to get best performance on x86 target.
    # For x86 machine supports AVX512, the complete target is
    # "llvm -mcpu=skylake-avx512 -libs=mkl"
    target = "llvm"

    with tvm.transform.PassContext(opt_level=3, disabled_pass=["FoldScaleAxis"]):
        vm_exec = relay.vm.compile(mod, target=target, params=params)







Inference with Relay VM
-----------------------


.. code-block:: default

    dev = tvm.cpu()
    vm = VirtualMachine(vm_exec, dev)
    vm.set_input("main", **{input_name: img})
    tvm_res = vm.run()







Get boxes with score larger than 0.9
------------------------------------


.. code-block:: default

    score_threshold = 0.9
    boxes = tvm_res[0].numpy().tolist()
    valid_boxes = []
    for i, score in enumerate(tvm_res[1].numpy().tolist()):
        if score > score_threshold:
            valid_boxes.append(boxes[i])
        else:
            break

    print("Get {} valid boxes".format(len(valid_boxes)))




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Get 9 valid boxes




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 3 minutes  4.784 seconds)


.. _sphx_glr_download_how_to_deploy_models_deploy_object_detection_pytorch.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: deploy_object_detection_pytorch.py <deploy_object_detection_pytorch.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: deploy_object_detection_pytorch.ipynb <deploy_object_detection_pytorch.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
