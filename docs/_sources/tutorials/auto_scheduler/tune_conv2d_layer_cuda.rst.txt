.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_tutorials_auto_scheduler_tune_conv2d_layer_cuda.py>` to download the full example code
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_auto_scheduler_tune_conv2d_layer_cuda.py:


.. _auto-scheduler-conv-gpu:

Auto-scheduling a convolution layer for GPU
===========================================
**Author**: `Lianmin Zheng <https://github.com/merrymercy>`_,             `Chengfan Jia <https://github.com/jcf94/>`_


Different from the existing :ref:`autotvm <tutorials-autotvm-sec>` which relies on 
manual templates to define the search space, the auto-scheduler does not require any templates.
The auto-scheduler is template-free, so users only need to write the computation declaration without
any schedule commands or templates.
The auto-scheduler can automatically generate a large
search space and find a good schedule in the space.

We use a convolution layer as an example in this tutorial.


.. code-block:: default


    import numpy as np
    import tvm
    from tvm import te, auto_scheduler, topi
    from tvm.topi.testing import conv2d_nchw_python







Define the computation
^^^^^^^^^^^^^^^^^^^^^^
To begin with, let us define the computation of a convolution layer.
The function should return the list of input/output tensors.
From these tensors, the auto-scheduler can get the whole computational graph.


.. code-block:: default



    @auto_scheduler.register_workload
    def conv2d_layer(N, H, W, CO, CI, KH, KW, stride, padding):
        data = te.placeholder((N, CI, H, W), name="data")
        kernel = te.placeholder((CO, CI, KH, KW), name="kernel")
        bias = te.placeholder((1, CO, 1, 1), name="bias")
        conv = topi.nn.conv2d_nchw(data, kernel, stride, padding, dilation=1, out_dtype="float32")
        out = topi.nn.relu(conv + bias)
        return [data, kernel, bias, out]








Create the search task
^^^^^^^^^^^^^^^^^^^^^^
We then create a search task for the last convolution layer in the resnet.


.. code-block:: default


    target = tvm.target.Target("cuda")

    # the last layer in resnet
    N, H, W, CO, CI, KH, KW, strides, padding = 1, 7, 7, 512, 512, 3, 3, (1, 1), (1, 1)
    task = auto_scheduler.create_task(conv2d_layer, (N, H, W, CO, CI, KH, KW, strides, padding), target)

    # Inspect the computational graph
    print(task.compute_dag)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    data = PLACEHOLDER [1, 512, 7, 7]
    pad_temp(i0, i1, i2, i3) = tir.if_then_else(((((i2 >= 1) && (i2 < 8)) && (i3 >= 1)) && (i3 < 8)), data[i0, i1, (i2 - 1), (i3 - 1)], 0f)
    kernel = PLACEHOLDER [512, 512, 3, 3]
    compute(nn, ff, yy, xx) += (pad_temp[nn, rc, (yy + ry), (xx + rx)]*kernel[ff, rc, ry, rx])
    bias = PLACEHOLDER [1, 512, 1, 1]
    T_add(ax0, ax1, ax2, ax3) = (compute[ax0, ax1, ax2, ax3] + bias[ax0, ax1, 0, 0])
    compute(i0, i1, i2, i3) = max(T_add[i0, i1, i2, i3], 0f)




Next, we set parameters for the auto-scheduler. These parameters
mainly specify how we do the measurement during the search and auto-tuning.

* :code:`measure_ctx` launches a different process for measurement. This
  provides an isolation. It can protect the master process from GPU crashes
  happended during measurement and avoid other runtime conflicts.
* :code:`min_repeat_ms` defines the minimum duration of one "repeat" in every measurement.
  This can warmup the GPU, which is necessary to get accurate measurement results.
  Typically, we recommend a value > 300 ms.
* :code:`num_measure_trials` is the number of measurement trials we can use during the search.
  We only make 10 trials in this tutorial for a fast demonstration. In practice, 1000 is a
  good value for the search to converge. You can do more trials according to your time budget.
* In addition, we use :code:`RecordToFile` to dump measurement records into a file `conv2d.json`.
  The measurement records can be used to query the history best, resume the search,
  and do more analyses later.
* see :any:`auto_scheduler.TuningOptions`,
  :any:`auto_scheduler.LocalRPCMeasureContext` for more parameters.


.. code-block:: default


    measure_ctx = auto_scheduler.LocalRPCMeasureContext(min_repeat_ms=300)
    tune_option = auto_scheduler.TuningOptions(
        num_measure_trials=10,
        runner=measure_ctx.runner,
        measure_callbacks=[auto_scheduler.RecordToFile("conv2d.json")],
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Get devices for measurement successfully!



Run the search
^^^^^^^^^^^^^^
Now we get all inputs ready. Pretty simple, isn't it?
We can kick off the search and let the auto-scheduler do its magic.
After some measurement trials, it will return the best schedule it found.


.. code-block:: default


    sch, args = auto_scheduler.auto_schedule(task, tuning_options=tune_option)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none





We can lower the schedule to see the IR after auto-scheduling.
The auto-scheduler correctly performs optimizations including multi-level tiling,
cooperative fetching, unrolling and operator fusion.


.. code-block:: default


    print(tvm.lower(sch, args, simple_mode=True))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    primfn(data_1: handle, kernel_1: handle, bias_1: handle, compute_1: handle) -> ()
      attr = {"global_symbol": "main", "tir.noalias": True}
      buffers = {compute: Buffer(compute_2: Pointer(float32), float32, [1, 512, 7, 7], []),
                 bias: Buffer(bias_2: Pointer(float32), float32, [1, 512, 1, 1], []),
                 kernel: Buffer(kernel_2: Pointer(float32), float32, [512, 512, 3, 3], []),
                 data: Buffer(data_2: Pointer(float32), float32, [1, 512, 7, 7], [])}
      buffer_map = {data_1: data, kernel_1: kernel, bias_1: bias, compute_1: compute} {
      attr [IterVar(blockIdx.x: int32, (nullptr), "ThreadIndex", "blockIdx.x")] "thread_extent" = 28;
      attr [compute_3: Pointer(float32)] "storage_scope" = "local";
      allocate(compute_3, float32, [16]);
      attr [pad_temp.shared: Pointer(float32)] "storage_scope" = "shared";
      allocate(pad_temp.shared, float32, [144]);
      attr [kernel.shared: Pointer(float32)] "storage_scope" = "shared";
      allocate(kernel.shared, float32, [6144]);
      attr [IterVar(threadIdx.x: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 56 {
        compute_3[0] = 0f32
        compute_3[4] = 0f32
        compute_3[8] = 0f32
        compute_3[12] = 0f32
        compute_3[1] = 0f32
        compute_3[5] = 0f32
        compute_3[9] = 0f32
        compute_3[13] = 0f32
        compute_3[2] = 0f32
        compute_3[6] = 0f32
        compute_3[10] = 0f32
        compute_3[14] = 0f32
        compute_3[3] = 0f32
        compute_3[7] = 0f32
        compute_3[11] = 0f32
        compute_3[15] = 0f32
        for (rc.outer.outer: int32, 0, 32) {
          for (ry.outer.outer: int32, 0, 3) {
            attr [IterVar(threadIdx.x_1: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 56;
            pad_temp.shared[threadIdx.x_1] = @tir.if_then_else(((((1 <= (ry.outer.outer + floormod(blockIdx.x, 7))) && ((ry.outer.outer + floormod(blockIdx.x, 7)) < 8)) && (1 <= floormod(threadIdx.x_1, 9))) && (floormod(threadIdx.x_1, 9) < 8)), (float32*)data_2[((((((rc.outer.outer*784) + (floordiv(threadIdx.x_1, 9)*49)) + (ry.outer.outer*7)) + (floormod(blockIdx.x, 7)*7)) + floormod(threadIdx.x_1, 9)) - 8)], 0f32, dtype=float32)
            attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 56;
            pad_temp.shared[(threadIdx.x_1 + 56)] = @tir.if_then_else(((((1 <= (ry.outer.outer + floormod(blockIdx.x, 7))) && ((ry.outer.outer + floormod(blockIdx.x, 7)) < 8)) && (1 <= floormod((threadIdx.x_1 + 2), 9))) && (floormod((threadIdx.x_1 + 2), 9) < 8)), (float32*)data_2[((((((rc.outer.outer*784) + (floordiv((threadIdx.x_1 + 56), 9)*49)) + (ry.outer.outer*7)) + (floormod(blockIdx.x, 7)*7)) + floormod((threadIdx.x_1 + 2), 9)) - 8)], 0f32, dtype=float32)
            attr [IterVar(threadIdx.x_1, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 56;
            if @tir.likely((threadIdx.x_1 < 32), dtype=bool) {
              pad_temp.shared[(threadIdx.x_1 + 112)] = @tir.if_then_else(((((1 <= (ry.outer.outer + floormod(blockIdx.x, 7))) && ((ry.outer.outer + floormod(blockIdx.x, 7)) < 8)) && (1 <= floormod((threadIdx.x_1 + 4), 9))) && (floormod((threadIdx.x_1 + 4), 9) < 8)), (float32*)data_2[((((((rc.outer.outer*784) + (floordiv((threadIdx.x_1 + 112), 9)*49)) + (ry.outer.outer*7)) + (floormod(blockIdx.x, 7)*7)) + floormod((threadIdx.x_1 + 4), 9)) - 8)], 0f32, dtype=float32)
            }
            for (ax0.ax1.fused.ax2.fused.ax3.fused.outer.outer: int32, 0, 110) {
              attr [IterVar(threadIdx.x_2: int32, (nullptr), "ThreadIndex", "threadIdx.x")] "thread_extent" = 56;
              if @tir.likely((((ax0.ax1.fused.ax2.fused.ax3.fused.outer.outer*56) + threadIdx.x_2) < 6144), dtype=bool) {
                kernel.shared[((ax0.ax1.fused.ax2.fused.ax3.fused.outer.outer*56) + threadIdx.x_2)] = (float32*)kernel_2[((((((floordiv(blockIdx.x, 7)*589824) + (floordiv(((ax0.ax1.fused.ax2.fused.ax3.fused.outer.outer*56) + threadIdx.x_2), 48)*4608)) + (rc.outer.outer*144)) + (floordiv(floormod(((ax0.ax1.fused.ax2.fused.ax3.fused.outer.outer*56) + threadIdx.x_2), 48), 3)*9)) + (ry.outer.outer*3)) + floormod(((ax0.ax1.fused.ax2.fused.ax3.fused.outer.outer*56) + threadIdx.x_2), 3))]
              }
            }
            for (rx.outer.inner: int32, 0, 3) {
              for (ff.outer.inner: int32, 0, 4) {
                for (rc.inner: int32, 0, 16) {
                  compute_3[ff.outer.inner] = ((float32*)compute_3[ff.outer.inner] + ((float32*)pad_temp.shared[(((rc.inner*9) + rx.outer.inner) + floormod(threadIdx.x, 7))]*(float32*)kernel.shared[((((floordiv(threadIdx.x, 7)*192) + (ff.outer.inner*48)) + (rc.inner*3)) + rx.outer.inner)]))
                  compute_3[(ff.outer.inner + 4)] = ((float32*)compute_3[(ff.outer.inner + 4)] + ((float32*)pad_temp.shared[(((rc.inner*9) + rx.outer.inner) + floormod(threadIdx.x, 7))]*(float32*)kernel.shared[(((((floordiv(threadIdx.x, 7)*192) + (ff.outer.inner*48)) + (rc.inner*3)) + rx.outer.inner) + 1536)]))
                  compute_3[(ff.outer.inner + 8)] = ((float32*)compute_3[(ff.outer.inner + 8)] + ((float32*)pad_temp.shared[(((rc.inner*9) + rx.outer.inner) + floormod(threadIdx.x, 7))]*(float32*)kernel.shared[(((((floordiv(threadIdx.x, 7)*192) + (ff.outer.inner*48)) + (rc.inner*3)) + rx.outer.inner) + 3072)]))
                  compute_3[(ff.outer.inner + 12)] = ((float32*)compute_3[(ff.outer.inner + 12)] + ((float32*)pad_temp.shared[(((rc.inner*9) + rx.outer.inner) + floormod(threadIdx.x, 7))]*(float32*)kernel.shared[(((((floordiv(threadIdx.x, 7)*192) + (ff.outer.inner*48)) + (rc.inner*3)) + rx.outer.inner) + 4608)]))
                }
              }
            }
          }
        }
        for (i1.inner: int32, 0, 4) {
          compute_2[(((((floordiv(blockIdx.x, 7)*6272) + (floordiv(threadIdx.x, 7)*196)) + (i1.inner*49)) + (floormod(blockIdx.x, 7)*7)) + floormod(threadIdx.x, 7))] = max(((float32*)compute_3[i1.inner] + (float32*)bias_2[(((floordiv(blockIdx.x, 7)*128) + (floordiv(threadIdx.x, 7)*4)) + i1.inner)]), 0f32)
          compute_2[((((((floordiv(blockIdx.x, 7)*6272) + (floordiv(threadIdx.x, 7)*196)) + (i1.inner*49)) + (floormod(blockIdx.x, 7)*7)) + floormod(threadIdx.x, 7)) + 1568)] = max(((float32*)compute_3[(i1.inner + 4)] + (float32*)bias_2[((((floordiv(blockIdx.x, 7)*128) + (floordiv(threadIdx.x, 7)*4)) + i1.inner) + 32)]), 0f32)
          compute_2[((((((floordiv(blockIdx.x, 7)*6272) + (floordiv(threadIdx.x, 7)*196)) + (i1.inner*49)) + (floormod(blockIdx.x, 7)*7)) + floormod(threadIdx.x, 7)) + 3136)] = max(((float32*)compute_3[(i1.inner + 8)] + (float32*)bias_2[((((floordiv(blockIdx.x, 7)*128) + (floordiv(threadIdx.x, 7)*4)) + i1.inner) + 64)]), 0f32)
          compute_2[((((((floordiv(blockIdx.x, 7)*6272) + (floordiv(threadIdx.x, 7)*196)) + (i1.inner*49)) + (floormod(blockIdx.x, 7)*7)) + floormod(threadIdx.x, 7)) + 4704)] = max(((float32*)compute_3[(i1.inner + 12)] + (float32*)bias_2[((((floordiv(blockIdx.x, 7)*128) + (floordiv(threadIdx.x, 7)*4)) + i1.inner) + 96)]), 0f32)
        }
      }
    }





Check correctness and evaluate performance
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
We build the binary and check its correctness and performance.


.. code-block:: default


    func = tvm.build(sch, args, target)

    # check correctness
    data_np = np.random.uniform(size=(N, CI, H, W)).astype(np.float32)
    weight_np = np.random.uniform(size=(CO, CI, KH, KW)).astype(np.float32)
    bias_np = np.random.uniform(size=(1, CO, 1, 1)).astype(np.float32)
    conv_np = conv2d_nchw_python(data_np, weight_np, strides, padding)
    out_np = np.maximum(conv_np + bias_np, 0.0)

    ctx = tvm.gpu()
    data_tvm = tvm.nd.array(data_np, ctx=ctx)
    weight_tvm = tvm.nd.array(weight_np, ctx=ctx)
    bias_tvm = tvm.nd.array(bias_np, ctx=ctx)
    out_tvm = tvm.nd.empty(out_np.shape, ctx=ctx)
    func(data_tvm, weight_tvm, bias_tvm, out_tvm)

    # Check results
    np.testing.assert_allclose(out_np, out_tvm.asnumpy(), rtol=1e-3)

    # Evaluate execution time
    evaluator = func.time_evaluator(func.entry_name, ctx, min_repeat_ms=500)
    print(
        "Execution time of this operator: %.3f ms"
        % (np.median(evaluator(data_tvm, weight_tvm, bias_tvm, out_tvm).results) * 1000)
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Execution time of this operator: 1.361 ms



Using the record file
^^^^^^^^^^^^^^^^^^^^^
During the search, all measuremnt records are dumpped into the record
file "conv2d.json". The measurement records can be used to re-apply search results,
resume the search, and perform other analyses.

Here is an example where we load the best schedule from a file,
print the equivalent python schedule API, and build the binary again.


.. code-block:: default


    # Load the measuremnt record for the best schedule
    inp, res = auto_scheduler.load_best("conv2d.json", task.workload_key)

    # Print equivalent python schedule API. This can be used for debugging and
    # learning the behavior of the auto-scheduler.
    print("Equivalent python schedule:")
    print(task.compute_dag.print_python_code_from_state(inp.state))

    # Rebuild the binary. This shows how you can apply the best schedule from a
    # log file without reruning the search again.
    sch, args = task.compute_dag.apply_steps_from_state(inp.state)
    func = tvm.build(sch, args, target)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Equivalent python schedule:
    i0, i1, i2, i3 = tuple(pad_temp.op.axis) + tuple(pad_temp.op.reduce_axis)
    nn, ff, yy, xx, rc, ry, rx = tuple(compute.op.axis) + tuple(compute.op.reduce_axis)
    ax0, ax1, ax2, ax3 = tuple(T_add.op.axis) + tuple(T_add.op.reduce_axis)
    i0, i1, i2, i3 = tuple(compute.op.axis) + tuple(compute.op.reduce_axis)
    s[T_add].compute_inline()
    nn_o_i, nn_i = s[compute].split(nn, factor=1)
    nn_o_o_i, nn_o_i = s[compute].split(nn_o_i, factor=1)
    nn_o_o_o_i, nn_o_o_i = s[compute].split(nn_o_o_i, factor=1)
    nn_o_o_o_o, nn_o_o_o_i = s[compute].split(nn_o_o_o_i, factor=1)
    ff_o_i, ff_i = s[compute].split(ff, factor=1)
    ff_o_o_i, ff_o_i = s[compute].split(ff_o_i, factor=1)
    ff_o_o_o_i, ff_o_o_i = s[compute].split(ff_o_o_i, factor=16)
    ff_o_o_o_o, ff_o_o_o_i = s[compute].split(ff_o_o_o_i, factor=1)
    yy_o_i, yy_i = s[compute].split(yy, factor=1)
    yy_o_o_i, yy_o_i = s[compute].split(yy_o_i, factor=7)
    yy_o_o_o_i, yy_o_o_i = s[compute].split(yy_o_o_i, factor=1)
    yy_o_o_o_o, yy_o_o_o_i = s[compute].split(yy_o_o_o_i, factor=1)
    xx_o_i, xx_i = s[compute].split(xx, factor=1)
    xx_o_o_i, xx_o_i = s[compute].split(xx_o_i, factor=1)
    xx_o_o_o_i, xx_o_o_i = s[compute].split(xx_o_o_i, factor=7)
    xx_o_o_o_o, xx_o_o_o_i = s[compute].split(xx_o_o_o_i, factor=1)
    rc_o_i, rc_i = s[compute].split(rc, factor=1)
    rc_o_o, rc_o_i = s[compute].split(rc_o_i, factor=16)
    ry_o_i, ry_i = s[compute].split(ry, factor=3)
    ry_o_o, ry_o_i = s[compute].split(ry_o_i, factor=1)
    rx_o_i, rx_i = s[compute].split(rx, factor=1)
    rx_o_o, rx_o_i = s[compute].split(rx_o_i, factor=3)
    s[compute].reorder(nn_o_o_o_o, ff_o_o_o_o, yy_o_o_o_o, xx_o_o_o_o, nn_o_o_o_i, ff_o_o_o_i, yy_o_o_o_i, xx_o_o_o_i, nn_o_o_i, ff_o_o_i, yy_o_o_i, xx_o_o_i, rc_o_o, ry_o_o, rx_o_o, rc_o_i, ry_o_i, rx_o_i, nn_o_i, ff_o_i, yy_o_i, xx_o_i, rc_i, ry_i, rx_i, nn_i, ff_i, yy_i, xx_i)
    i0_o_i, i0_i = s[compute].split(i0, factor=1)
    i0_o_o_i, i0_o_i = s[compute].split(i0_o_i, factor=1)
    i0_o_o_o, i0_o_o_i = s[compute].split(i0_o_o_i, factor=1)
    i1_o_i, i1_i = s[compute].split(i1, factor=1)
    i1_o_o_i, i1_o_i = s[compute].split(i1_o_i, factor=16)
    i1_o_o_o, i1_o_o_i = s[compute].split(i1_o_o_i, factor=1)
    i2_o_i, i2_i = s[compute].split(i2, factor=7)
    i2_o_o_i, i2_o_i = s[compute].split(i2_o_i, factor=1)
    i2_o_o_o, i2_o_o_i = s[compute].split(i2_o_o_i, factor=1)
    i3_o_i, i3_i = s[compute].split(i3, factor=1)
    i3_o_o_i, i3_o_i = s[compute].split(i3_o_i, factor=7)
    i3_o_o_o, i3_o_o_i = s[compute].split(i3_o_o_i, factor=1)
    s[compute].reorder(i0_o_o_o, i1_o_o_o, i2_o_o_o, i3_o_o_o, i0_o_o_i, i1_o_o_i, i2_o_o_i, i3_o_o_i, i0_o_i, i1_o_i, i2_o_i, i3_o_i, i0_i, i1_i, i2_i, i3_i)
    s[compute].compute_at(s[compute], i3_o_i)
    kernel_shared = s.cache_read(kernel, "shared", [compute])
    ax0, ax1, ax2, ax3 = tuple(kernel_shared.op.axis)
    s[kernel_shared].compute_at(s[compute], rx_o_o)
    pad_temp_shared = s.cache_read(pad_temp, "shared", [compute])
    ax0, ax1, ax2, ax3 = tuple(pad_temp_shared.op.axis)
    s[pad_temp_shared].compute_at(s[compute], rx_o_o)
    s[pad_temp].compute_inline()
    i0_o_o_o_i1_o_o_o_fused_i2_o_o_o_fused_i3_o_o_o_fused = s[compute].fuse(i0_o_o_o, i1_o_o_o, i2_o_o_o, i3_o_o_o)
    s[compute].bind(i0_o_o_o_i1_o_o_o_fused_i2_o_o_o_fused_i3_o_o_o_fused, tvm.thread_axis("blockIdx.x"))
    i0_o_o_i_i1_o_o_i_fused_i2_o_o_i_fused_i3_o_o_i_fused = s[compute].fuse(i0_o_o_i, i1_o_o_i, i2_o_o_i, i3_o_o_i)
    s[compute].bind(i0_o_o_i_i1_o_o_i_fused_i2_o_o_i_fused_i3_o_o_i_fused, tvm.thread_axis("vthread"))
    i0_o_i_i1_o_i_fused_i2_o_i_fused_i3_o_i_fused = s[compute].fuse(i0_o_i, i1_o_i, i2_o_i, i3_o_i)
    s[compute].bind(i0_o_i_i1_o_i_fused_i2_o_i_fused_i3_o_i_fused, tvm.thread_axis("threadIdx.x"))
    ax0_ax1_fused_ax2_fused_ax3_fused = s[kernel_shared].fuse(ax0, ax1, ax2, ax3)
    ax0_ax1_fused_ax2_fused_ax3_fused_o, ax0_ax1_fused_ax2_fused_ax3_fused_i = s[kernel_shared].split(ax0_ax1_fused_ax2_fused_ax3_fused, factor=3)
    s[kernel_shared].vectorize(ax0_ax1_fused_ax2_fused_ax3_fused_i)
    ax0_ax1_fused_ax2_fused_ax3_fused_o_o, ax0_ax1_fused_ax2_fused_ax3_fused_o_i = s[kernel_shared].split(ax0_ax1_fused_ax2_fused_ax3_fused_o, factor=112)
    s[kernel_shared].bind(ax0_ax1_fused_ax2_fused_ax3_fused_o_i, tvm.thread_axis("threadIdx.x"))
    ax0_ax1_fused_ax2_fused_ax3_fused = s[pad_temp_shared].fuse(ax0, ax1, ax2, ax3)
    ax0_ax1_fused_ax2_fused_ax3_fused_o, ax0_ax1_fused_ax2_fused_ax3_fused_i = s[pad_temp_shared].split(ax0_ax1_fused_ax2_fused_ax3_fused, factor=9)
    s[pad_temp_shared].vectorize(ax0_ax1_fused_ax2_fused_ax3_fused_i)
    ax0_ax1_fused_ax2_fused_ax3_fused_o_o, ax0_ax1_fused_ax2_fused_ax3_fused_o_i = s[pad_temp_shared].split(ax0_ax1_fused_ax2_fused_ax3_fused_o, factor=112)
    s[pad_temp_shared].bind(ax0_ax1_fused_ax2_fused_ax3_fused_o_i, tvm.thread_axis("threadIdx.x"))
    s[compute].pragma(nn_o_o_o_o, "auto_unroll_max_step", 1024)
    s[compute].pragma(nn_o_o_o_o, "unroll_explicit", True)




A more complicated example is to resume the search.
In this case, we need to create the search policy and cost model by ourselves
and resume the status of search policy and cost model with the log file.
In the example below we resume the status and do more 5 trials.


.. code-block:: default



    log_file = "conv2d.json"
    cost_model = auto_scheduler.XGBModel()
    cost_model.update_from_file(log_file)
    search_policy = auto_scheduler.SketchPolicy(
        task, cost_model, init_search_callbacks=[auto_scheduler.PreloadMeasuredStates(log_file)]
    )
    tune_option = auto_scheduler.TuningOptions(
        num_measure_trials=5,
        runner=measure_ctx.runner,
        measure_callbacks=[auto_scheduler.RecordToFile(log_file)],
    )
    sch, args = auto_scheduler.auto_schedule(task, search_policy, tuning_options=tune_option)

    # kill the measurement process
    del measure_ctx




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  56.708 seconds)


.. _sphx_glr_download_tutorials_auto_scheduler_tune_conv2d_layer_cuda.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download

     :download:`Download Python source code: tune_conv2d_layer_cuda.py <tune_conv2d_layer_cuda.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: tune_conv2d_layer_cuda.ipynb <tune_conv2d_layer_cuda.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
