<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::tir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html">attr</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1builtin"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1builtin.html">builtin</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1builtin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of builtin intrinsics as ops. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AddNode.html" title="a + b ">AddNode</a>.  <a href="classtvm_1_1tir_1_1Add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AddNode.html">AddNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a + b  <a href="classtvm_1_1tir_1_1AddNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Allocate.html">Allocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AllocateNode.html" title="Allocate a buffer that can be used in body. ">AllocateNode</a>.  <a href="classtvm_1_1tir_1_1Allocate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AllocateNode.html">AllocateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Allocate.html" title="Managed reference to AllocateNode. ">Allocate</a> a buffer that can be used in body.  <a href="classtvm_1_1tir_1_1AllocateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1And.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AndNode.html" title="a &amp;&amp; b ">AndNode</a>.  <a href="classtvm_1_1tir_1_1And.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AndNode.html">AndNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &amp;&amp; b  <a href="classtvm_1_1tir_1_1AndNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Any.html">Any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AnyNode.html" title="Any shape. ">AnyNode</a>.  <a href="classtvm_1_1tir_1_1Any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AnyNode.html">AnyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Any.html" title="Managed reference to AnyNode. ">Any</a> shape.  <a href="classtvm_1_1tir_1_1AnyNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AssertStmt.html">AssertStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AssertStmtNode.html" title="Assert condition, if an error occurs, return the error message. ">AssertStmtNode</a>.  <a href="classtvm_1_1tir_1_1AssertStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AssertStmtNode.html">AssertStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert condition, if an error occurs, return the error message.  <a href="classtvm_1_1tir_1_1AssertStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AttrStmt.html">AttrStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1AttrStmtNode.html" title="Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary inform...">AttrStmtNode</a>.  <a href="classtvm_1_1tir_1_1AttrStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AttrStmtNode.html">AttrStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary information for IR passes that transforms body.  <a href="classtvm_1_1tir_1_1AttrStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BijectiveLayout.html">BijectiveLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bijective function mapping for data layout transformation. Given two <a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode. ">Layout</a>, <a class="el" href="classtvm_1_1tir_1_1BijectiveLayout.html" title="Bijective function mapping for data layout transformation. Given two Layout, BijectiveLayout build an...">BijectiveLayout</a> build and store the mapping rules, provides API to transform N-dimention tensor from the source indices (i0, i1, .., im) to the destination indices (j0, j1, .., jm).  <a href="classtvm_1_1tir_1_1BijectiveLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BijectiveLayoutNode.html">BijectiveLayoutNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BinaryOpNode.html">BinaryOpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template to implement binary ops.  <a href="classtvm_1_1tir_1_1BinaryOpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Broadcast.html">Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BroadcastNode.html" title="Create a vector where all the elements are value. ">BroadcastNode</a>.  <a href="classtvm_1_1tir_1_1Broadcast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BroadcastNode.html">BroadcastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector where all the elements are value.  <a href="classtvm_1_1tir_1_1BroadcastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> is a symbolic n-darray structure. It is a composition of primitive symbolic types, used to specify the memory layout of the Tensor used in program input.  <a href="classtvm_1_1tir_1_1Buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferLoad.html">BufferLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferLoadNode.html" title="Load value from the high dimension buffer. ">BufferLoadNode</a>.  <a href="classtvm_1_1tir_1_1BufferLoad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferLoadNode.html">BufferLoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Load.html" title="Managed reference to LoadNode. ">Load</a> value from the high dimension buffer.  <a href="classtvm_1_1tir_1_1BufferLoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferNode.html">BufferNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node to represent a buffer.  <a href="classtvm_1_1tir_1_1BufferNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferRealize.html">BufferRealize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferRealizeNode.html" title="Annotate the region where the buffer need to be read and write in the body. We only need to allocate ...">BufferRealizeNode</a>.  <a href="classtvm_1_1tir_1_1BufferRealize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferRealizeNode.html">BufferRealizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate the region where the buffer need to be read and write in the body. We only need to allocate the space for the corresponding region.  <a href="classtvm_1_1tir_1_1BufferRealizeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferStore.html">BufferStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1BufferStoreNode.html" title="Store value to the high dimension buffer. ">BufferStoreNode</a>.  <a href="classtvm_1_1tir_1_1BufferStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferStoreNode.html">BufferStoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Store.html" title="Managed reference to StoreNode. ">Store</a> value to the high dimension buffer.  <a href="classtvm_1_1tir_1_1BufferStoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Call.html">Call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CallNode.html" title="Call node. ">CallNode</a>.  <a href="classtvm_1_1tir_1_1Call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> node.  <a href="classtvm_1_1tir_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CastNode.html" title="Cast value from one data type to another. ">CastNode</a>.  <a href="classtvm_1_1tir_1_1Cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CastNode.html">CastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Cast.html" title="Managed reference to CastNode. ">Cast</a> value from one data type to another.  <a href="classtvm_1_1tir_1_1CastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CmpOpNode.html">CmpOpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template to implement comparison ops.  <a href="classtvm_1_1tir_1_1CmpOpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CommReducer.html">CommReducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1CommReducerNode.html" title="A commutative reducer node to represent a commutative binary operator with identity element...">CommReducerNode</a>.  <a href="classtvm_1_1tir_1_1CommReducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CommReducerNode.html">CommReducerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A commutative reducer node to represent a commutative binary operator with identity element.  <a href="classtvm_1_1tir_1_1CommReducerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DataProducer.html">DataProducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DataProducerNode.html" title="Base node for data producers. ">DataProducerNode</a>.  <a href="classtvm_1_1tir_1_1DataProducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DataProducerNode.html">DataProducerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node for data producers.  <a href="classtvm_1_1tir_1_1DataProducerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Div.html">Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1DivNode.html" title="a / b in the C semnatics. ">DivNode</a>.  <a href="classtvm_1_1tir_1_1Div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DivNode.html">DivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a / b in the C semnatics.  <a href="classtvm_1_1tir_1_1DivNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EQ.html">EQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1EQNode.html" title="a == b ">EQNode</a>.  <a href="classtvm_1_1tir_1_1EQ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EQNode.html">EQNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a == b  <a href="classtvm_1_1tir_1_1EQNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Evaluate.html">Evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1EvaluateNode.html" title="Evaluates an expression. This is mostly used for putting a Call node into Stmt. ">EvaluateNode</a>.  <a href="classtvm_1_1tir_1_1Evaluate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EvaluateNode.html">EvaluateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates an expression. This is mostly used for putting a <a class="el" href="classtvm_1_1tir_1_1Call.html" title="Managed reference to CallNode. ">Call</a> node into <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>.  <a href="classtvm_1_1tir_1_1EvaluateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1ExprDeepEqual.html">ExprDeepEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two expressions recursively and check if they are equal to each other without var remapping.  <a href="structtvm_1_1tir_1_1ExprDeepEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit Function.  <a href="classtvm_1_1tir_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprFunctor_3_01R_07const_01PrimExpr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const PrimExpr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1ExprMutator.html" title="ExprMutator that mutates expressions. ">ExprMutator</a> that mutates expressions.  <a href="classtvm_1_1tir_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1ExprVisitor.html" title="ExprVisitor. ">ExprVisitor</a>.  <a href="classtvm_1_1tir_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorDiv.html">FloorDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1FloorDivNode.html" title="Floor division, floor(a/b) ">FloorDivNode</a>.  <a href="classtvm_1_1tir_1_1FloorDiv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorDivNode.html">FloorDivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor division, floor(a/b)  <a href="classtvm_1_1tir_1_1FloorDivNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorMod.html">FloorMod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1FloorModNode.html" title="The remainder of the floordiv. ">FloorModNode</a>.  <a href="classtvm_1_1tir_1_1FloorMod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorModNode.html">FloorModNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the floordiv.  <a href="classtvm_1_1tir_1_1FloorModNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1For.html">For</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ForNode.html" title="A for loop, with poissible type annotations. ">ForNode</a>.  <a href="classtvm_1_1tir_1_1For.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ForNode.html">ForNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop, with poissible type annotations.  <a href="classtvm_1_1tir_1_1ForNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GE.html">GE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1GENode.html" title="a &gt;= b ">GENode</a>.  <a href="classtvm_1_1tir_1_1GE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GENode.html">GENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt;= b  <a href="classtvm_1_1tir_1_1GENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GT.html">GT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1GTNode.html" title="a &gt; b ">GTNode</a>.  <a href="classtvm_1_1tir_1_1GT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GTNode.html">GTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt; b  <a href="classtvm_1_1tir_1_1GTNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IfThenElse.html">IfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1IfThenElseNode.html" title="IfThenElse statment. ">IfThenElseNode</a>.  <a href="classtvm_1_1tir_1_1IfThenElse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IfThenElseNode.html">IfThenElseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1IfThenElse.html" title="Managed reference to IfThenElseNode. ">IfThenElse</a> statment.  <a href="classtvm_1_1tir_1_1IfThenElseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteration Variable, represents an iteration over an integer interval.  <a href="classtvm_1_1tir_1_1IterVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IterVarNode.html">IterVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iteration variable representing an iteration over a one dimensional interval.  <a href="classtvm_1_1tir_1_1IterVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Layout.html">Layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LayoutNode.html" title="Layout is to describe how data is organized within an N-dimention tensor. It is composed of upper cas...">LayoutNode</a>.  <a href="classtvm_1_1tir_1_1Layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LayoutAxis.html">LayoutAxis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LayoutNode.html">LayoutNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode. ">Layout</a> is to describe how data is organized within an N-dimention tensor. It is composed of upper cases, lower cases and numbers, where upper case indicates a primal axis and the corresponding lower case with factor size indicates the subordinate axis. <a class="el" href="classtvm_1_1tir_1_1For.html" title="Managed reference to ForNode. ">For</a> example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. Here subordinate axis channel_block=16 is the factor size of the primal axis C (channel). <a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Managed reference to LayoutNode. ">Layout</a> for scalar is defined, while both its name and axes have size 0.  <a href="classtvm_1_1tir_1_1LayoutNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LE.html">LE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="structtvm_1_1tir_1_1LENode.html" title="a &lt;= b ">LENode</a>.  <a href="classtvm_1_1tir_1_1LE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1LENode.html">LENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt;= b  <a href="structtvm_1_1tir_1_1LENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Let.html">Let</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LetNode.html" title="Let binding. Bind var to value then evaluate body. ">LetNode</a>.  <a href="classtvm_1_1tir_1_1Let.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetNode.html">LetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Let.html" title="Managed reference to LetNode. ">Let</a> binding. Bind var to value then evaluate body.  <a href="classtvm_1_1tir_1_1LetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetStmt.html">LetStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LetStmtNode.html" title="Let binding, bind var to value, then run body. ">LetStmtNode</a>.  <a href="classtvm_1_1tir_1_1LetStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetStmtNode.html">LetStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Let.html" title="Managed reference to LetNode. ">Let</a> binding, bind var to value, then run body.  <a href="classtvm_1_1tir_1_1LetStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Load.html">Load</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LoadNode.html" title="Load the value from buffer_var. ">LoadNode</a>.  <a href="classtvm_1_1tir_1_1Load.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LoadNode.html">LoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Load.html" title="Managed reference to LoadNode. ">Load</a> the value from buffer_var.  <a href="classtvm_1_1tir_1_1LoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LT.html">LT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1LTNode.html" title="a &lt; b ">LTNode</a>.  <a href="classtvm_1_1tir_1_1LT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LTNode.html">LTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt; b  <a href="classtvm_1_1tir_1_1LTNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MaxNode.html" title="max(a, b) ">MaxNode</a>.  <a href="classtvm_1_1tir_1_1Max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MaxNode.html">MaxNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">max(a, b)  <a href="classtvm_1_1tir_1_1MaxNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MinNode.html" title="min(a, b) ">MinNode</a>.  <a href="classtvm_1_1tir_1_1Min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MinNode.html">MinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">min(a, b)  <a href="classtvm_1_1tir_1_1MinNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Mod.html">Mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ModNode.html" title="a % b in the C semnatics. ">ModNode</a>.  <a href="classtvm_1_1tir_1_1Mod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ModNode.html">ModNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a % b in the C semnatics.  <a href="classtvm_1_1tir_1_1ModNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Mul.html">Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1MulNode.html" title="a * b ">MulNode</a>.  <a href="classtvm_1_1tir_1_1Mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MulNode.html">MulNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a * b  <a href="classtvm_1_1tir_1_1MulNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NE.html">NE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1NENode.html" title="a != b ">NENode</a>.  <a href="classtvm_1_1tir_1_1NE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NENode.html">NENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a != b  <a href="classtvm_1_1tir_1_1NENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1NotNode.html" title="!a ">NotNode</a>.  <a href="classtvm_1_1tir_1_1Not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NotNode.html">NotNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">!a  <a href="classtvm_1_1tir_1_1NotNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1OrNode.html" title="a || b ">OrNode</a>.  <a href="classtvm_1_1tir_1_1Or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1OrNode.html">OrNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a || b  <a href="classtvm_1_1tir_1_1OrNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Prefetch.html">Prefetch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1PrefetchNode.html" title="A prefetch hint for abuffer. ">PrefetchNode</a>.  <a href="classtvm_1_1tir_1_1Prefetch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrefetchNode.html">PrefetchNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prefetch hint for abuffer.  <a href="classtvm_1_1tir_1_1PrefetchNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html" title="Primitive functions that contains TIR statements. ">PrimFuncNode</a>.  <a href="classtvm_1_1tir_1_1PrimFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html">PrimFuncNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive functions that contains TIR statements.  <a href="classtvm_1_1tir_1_1PrimFuncNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerLoad.html">ProducerLoad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ProducerLoadNode.html" title="Load value from the result produced by the producer. ">ProducerLoadNode</a>.  <a href="classtvm_1_1tir_1_1ProducerLoad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerLoadNode.html">ProducerLoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Load.html" title="Managed reference to LoadNode. ">Load</a> value from the result produced by the producer.  <a href="classtvm_1_1tir_1_1ProducerLoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerRealize.html">ProducerRealize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ProducerRealizeNode.html" title="Annotate the bounds where the data produced by the producer need to be written and read in body...">ProducerRealizeNode</a>.  <a href="classtvm_1_1tir_1_1ProducerRealize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerRealizeNode.html">ProducerRealizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate the bounds where the data produced by the producer need to be written and read in body. We will need to allocate space for the corresponding regions.  <a href="classtvm_1_1tir_1_1ProducerRealizeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerStore.html">ProducerStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ProducerStoreNode.html" title="Store value into mult-dimensional array that will be read by the consumer of the producer. ">ProducerStoreNode</a>.  <a href="classtvm_1_1tir_1_1ProducerStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerStoreNode.html">ProducerStoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Store.html" title="Managed reference to StoreNode. ">Store</a> value into mult-dimensional array that will be read by the consumer of the producer.  <a href="classtvm_1_1tir_1_1ProducerStoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1RampNode.html" title="Construct a vector with lanes elements where its i-th element equals base + i * stride. This is useful to construct a index for a continuous vector load. ">RampNode</a>.  <a href="classtvm_1_1tir_1_1Ramp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1RampNode.html">RampNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with lanes elements where its i-th element equals base + i * stride. This is useful to construct a index for a continuous vector load.  <a href="classtvm_1_1tir_1_1RampNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Reduce.html">Reduce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ReduceNode.html" title="Reduction operator operator. ">ReduceNode</a>.  <a href="classtvm_1_1tir_1_1Reduce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ReduceNode.html">ReduceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction operator operator.  <a href="classtvm_1_1tir_1_1ReduceNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SelectNode.html" title="return true_value if condition is true, otherwise return false_value. ">SelectNode</a>.  <a href="classtvm_1_1tir_1_1Select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SelectNode.html">SelectNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true_value if condition is true, otherwise return false_value.  <a href="classtvm_1_1tir_1_1SelectNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmt.html">SeqStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence statement.  <a href="classtvm_1_1tir_1_1SeqStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmtNode.html">SeqStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container of seq statement. Represent a sequence of statements.  <a href="classtvm_1_1tir_1_1SeqStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Shuffle.html">Shuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1ShuffleNode.html" title="Shuffle instruction. vec = concat(vectors) result = (vec[indices[0]], vec[indices[1]] ...">ShuffleNode</a>.  <a href="classtvm_1_1tir_1_1Shuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ShuffleNode.html">ShuffleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Shuffle.html" title="Managed reference to ShuffleNode. ">Shuffle</a> instruction. vec = concat(vectors) result = (vec[indices[0]], vec[indices[1]] ...)  <a href="classtvm_1_1tir_1_1ShuffleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SizeVar.html">SizeVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a named variable represents a tensor index size  <a href="classtvm_1_1tir_1_1SizeVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SizeVarNode.html">SizeVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable node represent a tensor index size, whose value must be non-negative.  <a href="classtvm_1_1tir_1_1SizeVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all statements.  <a href="classtvm_1_1tir_1_1Stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtExprMutator.html">StmtExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutator that recursively mutates stmts and exprs on them.  <a href="classtvm_1_1tir_1_1StmtExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtExprVisitor.html">StmtExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor that recursively visit stmts and exprs on them.  <a href="classtvm_1_1tir_1_1StmtExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtFunctor.html">StmtFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classtvm_1_1tir_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> except it is applied on statements.  <a href="classtvm_1_1tir_1_1StmtFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8args_08_4.html">StmtFunctor&lt; R(const Stmt &amp;n, Args...args)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtMutator.html">StmtMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1StmtMutator.html" title="StmtMutator that mutates the statements. ">StmtMutator</a> that mutates the statements.  <a href="classtvm_1_1tir_1_1StmtMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node of all statements.  <a href="classtvm_1_1tir_1_1StmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtVisitor.html">StmtVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1StmtVisitor.html" title="StmtVisitor. ">StmtVisitor</a>.  <a href="classtvm_1_1tir_1_1StmtVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Store.html">Store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1StoreNode.html" title="Store value to the buffer. ">StoreNode</a>.  <a href="classtvm_1_1tir_1_1Store.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StoreNode.html">StoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Store.html" title="Managed reference to StoreNode. ">Store</a> value to the buffer.  <a href="classtvm_1_1tir_1_1StoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StringImm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1StringImmNode.html" title="String constants, only used in asserts. ">StringImmNode</a>.  <a href="classtvm_1_1tir_1_1StringImm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StringImmNode.html">StringImmNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants, only used in asserts.  <a href="classtvm_1_1tir_1_1StringImmNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Sub.html">Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1SubNode.html" title="a - b ">SubNode</a>.  <a href="classtvm_1_1tir_1_1Sub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SubNode.html">SubNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a - b  <a href="classtvm_1_1tir_1_1SubNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a named variable in TIR  <a href="classtvm_1_1tir_1_1Var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable node in the IR.  <a href="classtvm_1_1tir_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae8c7db788e840dc1c2ed1f365d5ea829"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae8c7db788e840dc1c2ed1f365d5ea829">IntImmNode</a> = <a class="el" href="classtvm_1_1IntImmNode.html">tvm::IntImmNode</a></td></tr>
<tr class="separator:ae8c7db788e840dc1c2ed1f365d5ea829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb123be81447d2871f4c716ce2d1dc00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#adb123be81447d2871f4c716ce2d1dc00">FloatImmNode</a> = <a class="el" href="classtvm_1_1FloatImmNode.html">tvm::FloatImmNode</a></td></tr>
<tr class="separator:adb123be81447d2871f4c716ce2d1dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a81e48fe15eb305b96806e55e01a8c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a0a81e48fe15eb305b96806e55e01a8c1">TGlobalSymbol</a> = <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td></tr>
<tr class="memdesc:a0a81e48fe15eb305b96806e55e01a8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global symbol of the op after lowering.  <a href="#a0a81e48fe15eb305b96806e55e01a8c1">More...</a><br /></td></tr>
<tr class="separator:a0a81e48fe15eb305b96806e55e01a8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a0c5d42cf669b8ceeb42aa13d95cb5262">TVectorizable</a> = bool</td></tr>
<tr class="memdesc:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the op is overloaded for vector form.  <a href="#a0c5d42cf669b8ceeb42aa13d95cb5262">More...</a><br /></td></tr>
<tr class="separator:a0c5d42cf669b8ceeb42aa13d95cb5262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651e82a046f157a7d286b0985b3edb84"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a651e82a046f157a7d286b0985b3edb84">TCallEffectKind</a> = <a class="el" href="classtvm_1_1Integer.html">Integer</a></td></tr>
<tr class="memdesc:a651e82a046f157a7d286b0985b3edb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use integer to record the kind.  <a href="#a651e82a046f157a7d286b0985b3edb84">More...</a><br /></td></tr>
<tr class="separator:a651e82a046f157a7d286b0985b3edb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8277e2a3d81a80a4776705673df51e0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8277e2a3d81a80a4776705673df51e0a">Region</a> = Array&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;</td></tr>
<tr class="separator:a8277e2a3d81a80a4776705673df51e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">BufferType</a> : int { <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39">kDefault</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663">kAutoBroadcast</a> = 2
 }<tr class="memdesc:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer type  <a href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4a86b205145696c0555fd02bd37f46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a52c0b756f9ae7d0091ceb863a70e960b">CallEffectKind::kExprAnnotation</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a7ee78dd23fcf08988dfc48b55fce359a">CallEffectKind::kPure</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a8d8bb1cb393c8e093395350919eed4a7">CallEffectKind::kReadState</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46af5cd553beea158407e669139955fffe0">CallEffectKind::kUpdateState</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = kUpdateState, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46ac272fc9675a2a5836ff877d54427642b">CallEffectKind::kSpecialCallArg</a> = 4, 
<a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46a9d51682d02407dcdbbd4622cd54e4373">CallEffectKind::kEmbedInfo</a> = 5
<br />
 }<tr class="memdesc:a8f4a86b205145696c0555fd02bd37f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The effect type of the call.  <a href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8f4a86b205145696c0555fd02bd37f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">ForType</a> : int { <a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493">ForType::Serial</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131">ForType::Parallel</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725">ForType::Vectorized</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac">ForType::Unrolled</a> = 3
 }<tr class="memdesc:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional annotation of for loop.  <a href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed067b57db2923a07913239b2165e019"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aed067b57db2923a07913239b2165e019">DeviceAPI</a> : int { <a class="el" href="namespacetvm_1_1tir.html#aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754">DeviceAPI::None</a> = 0
 }</td></tr>
<tr class="separator:aed067b57db2923a07913239b2165e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422">kDataPar</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0">kThreadIndex</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4">kCommReduce</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b">kOrdered</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c">kOpaque</a> = 4, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5">kOpaque</a> = kUpdateState, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403">kUnrolled</a> = 5, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd">kVectorized</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652">kParallelized</a> = 7, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47">kTensorized</a> = 8
<br />
 }<tr class="memdesc:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iteration variable. Each IterVar have a specific type.  <a href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae110e02855d8bc12eb8b6f92ed391844"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae110e02855d8bc12eb8b6f92ed391844">UndefinedVars</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt, const Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;defs)</td></tr>
<tr class="memdesc:ae110e02855d8bc12eb8b6f92ed391844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the statement.  <a href="#ae110e02855d8bc12eb8b6f92ed391844">More...</a><br /></td></tr>
<tr class="separator:ae110e02855d8bc12eb8b6f92ed391844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99de316b20c7af2e8b4f06773ee69a5a"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a99de316b20c7af2e8b4f06773ee69a5a">UndefinedVars</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:a99de316b20c7af2e8b4f06773ee69a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the expression.  <a href="#a99de316b20c7af2e8b4f06773ee69a5a">More...</a><br /></td></tr>
<tr class="separator:a99de316b20c7af2e8b4f06773ee69a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aeb03afda344eb4d3a5d2d3fd4e1d266d">SideEffect</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze the side effect.  <a href="#aeb03afda344eb4d3a5d2d3fd4e1d266d">More...</a><br /></td></tr>
<tr class="separator:aeb03afda344eb4d3a5d2d3fd4e1d266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095d1c3c1ce2dc66285ec1a1e4fbacec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a095d1c3c1ce2dc66285ec1a1e4fbacec">ExprUseVar</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr, std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt; vset_contains)</td></tr>
<tr class="memdesc:a095d1c3c1ce2dc66285ec1a1e4fbacec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether e expression used any var in variable set..  <a href="#a095d1c3c1ce2dc66285ec1a1e4fbacec">More...</a><br /></td></tr>
<tr class="separator:a095d1c3c1ce2dc66285ec1a1e4fbacec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56573569b84c79678a7046a9500dbf73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a56573569b84c79678a7046a9500dbf73">ExprUseVar</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;expr, const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)</td></tr>
<tr class="memdesc:a56573569b84c79678a7046a9500dbf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether e expression used var.  <a href="#a56573569b84c79678a7046a9500dbf73">More...</a><br /></td></tr>
<tr class="separator:a56573569b84c79678a7046a9500dbf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b38edd60b6ff952cefb74842a8ae826"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a3b38edd60b6ff952cefb74842a8ae826">VerifySSA</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:a3b38edd60b6ff952cefb74842a8ae826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies whether the IR stmt or Expr is in SSA form. That is: each <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> is defined and assigned once(in Let/For)  <a href="#a3b38edd60b6ff952cefb74842a8ae826">More...</a><br /></td></tr>
<tr class="separator:a3b38edd60b6ff952cefb74842a8ae826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69bcf127843e5e671379e44ab47ca27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac69bcf127843e5e671379e44ab47ca27">VerifyMemory</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func)</td></tr>
<tr class="memdesc:ac69bcf127843e5e671379e44ab47ca27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if memory accesses are legal for a specific target device type.  <a href="#ac69bcf127843e5e671379e44ab47ca27">More...</a><br /></td></tr>
<tr class="separator:ac69bcf127843e5e671379e44ab47ca27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dfcb6ef7e178a83fda0bbb5dddcb39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a53dfcb6ef7e178a83fda0bbb5dddcb39">VerifyGPUCode</a> (const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;func, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; constraints)</td></tr>
<tr class="memdesc:a53dfcb6ef7e178a83fda0bbb5dddcb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit.  <a href="#a53dfcb6ef7e178a83fda0bbb5dddcb39">More...</a><br /></td></tr>
<tr class="separator:a53dfcb6ef7e178a83fda0bbb5dddcb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95263c55bfbd2c439b8144f1d7a83bef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a95263c55bfbd2c439b8144f1d7a83bef">decl_buffer</a> (Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; shape, <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype=<a class="el" href="classtvm_1_1runtime_1_1DataType.html#a237a714a6a16e14aa01fa4ac52426551">DataType::Float</a>(32), <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> name=&quot;buffer&quot;)</td></tr>
<tr class="memdesc:a95263c55bfbd2c439b8144f1d7a83bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new buffer given shape, and dtype.  <a href="#a95263c55bfbd2c439b8144f1d7a83bef">More...</a><br /></td></tr>
<tr class="separator:a95263c55bfbd2c439b8144f1d7a83bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb777c4f4d61883c0cbdf9116458b70d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:abb777c4f4d61883c0cbdf9116458b70d"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_map&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abb777c4f4d61883c0cbdf9116458b70d">as_unordered_map</a> (const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; K, V &gt; &amp;dmap)</td></tr>
<tr class="separator:abb777c4f4d61883c0cbdf9116458b70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd6ae7623f42cddbb05cc008c33711"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a48cd6ae7623f42cddbb05cc008c33711">IsPointerType</a> (const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;type, const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;element_type)</td></tr>
<tr class="memdesc:a48cd6ae7623f42cddbb05cc008c33711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type is a pointer to a runtime element type.  <a href="#a48cd6ae7623f42cddbb05cc008c33711">More...</a><br /></td></tr>
<tr class="separator:a48cd6ae7623f42cddbb05cc008c33711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea566597880d04bd62fbec687e338b5"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename  = typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4ea566597880d04bd62fbec687e338b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a4ea566597880d04bd62fbec687e338b5">make_const</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, ValueType value)</td></tr>
<tr class="memdesc:a4ea566597880d04bd62fbec687e338b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a const value with certain data type.  <a href="#a4ea566597880d04bd62fbec687e338b5">More...</a><br /></td></tr>
<tr class="separator:a4ea566597880d04bd62fbec687e338b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4408508a413fb7f3b2567f8d847dbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#adc4408508a413fb7f3b2567f8d847dbb">make_zero</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t)</td></tr>
<tr class="memdesc:adc4408508a413fb7f3b2567f8d847dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a const zero expr.  <a href="#adc4408508a413fb7f3b2567f8d847dbb">More...</a><br /></td></tr>
<tr class="separator:adc4408508a413fb7f3b2567f8d847dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40c127b53bca09d4c39f806a98dfdf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac40c127b53bca09d4c39f806a98dfdf8">const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:ac40c127b53bca09d4c39f806a98dfdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant true expression.  <a href="#ac40c127b53bca09d4c39f806a98dfdf8">More...</a><br /></td></tr>
<tr class="separator:ac40c127b53bca09d4c39f806a98dfdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11cb5c6f810546e5aa4e08a0684071a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae11cb5c6f810546e5aa4e08a0684071a">const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:ae11cb5c6f810546e5aa4e08a0684071a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant false expression.  <a href="#ae11cb5c6f810546e5aa4e08a0684071a">More...</a><br /></td></tr>
<tr class="separator:ae11cb5c6f810546e5aa4e08a0684071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe8f225faaf34c540194921a7ee6a66"><td class="memItemLeft" align="right" valign="top">const int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#acbe8f225faaf34c540194921a7ee6a66">as_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:acbe8f225faaf34c540194921a7ee6a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get x as constant int expression.  <a href="#acbe8f225faaf34c540194921a7ee6a66">More...</a><br /></td></tr>
<tr class="separator:acbe8f225faaf34c540194921a7ee6a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c414d5e54c099ad7287be302aac8f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5c414d5e54c099ad7287be302aac8f02">is_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x, int64_t value)</td></tr>
<tr class="memdesc:a5c414d5e54c099ad7287be302aac8f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer expression.  <a href="#a5c414d5e54c099ad7287be302aac8f02">More...</a><br /></td></tr>
<tr class="separator:a5c414d5e54c099ad7287be302aac8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8de8f843c6eb433b6ddfbf34e24099ef">is_no_op</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">tir::Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether stmt is nop.  <a href="#a8de8f843c6eb433b6ddfbf34e24099ef">More...</a><br /></td></tr>
<tr class="separator:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5104dcf0933da31329bb0b2580a947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9b5104dcf0933da31329bb0b2580a947">is_one</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a9b5104dcf0933da31329bb0b2580a947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer 1.  <a href="#a9b5104dcf0933da31329bb0b2580a947">More...</a><br /></td></tr>
<tr class="separator:a9b5104dcf0933da31329bb0b2580a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bad3db162b334837716bf8e7ba9285"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a48bad3db162b334837716bf8e7ba9285">is_zero</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a48bad3db162b334837716bf8e7ba9285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer 0.  <a href="#a48bad3db162b334837716bf8e7ba9285">More...</a><br /></td></tr>
<tr class="separator:a48bad3db162b334837716bf8e7ba9285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65923ae132fcc764357a8765878fb528"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a65923ae132fcc764357a8765878fb528">is_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a65923ae132fcc764357a8765878fb528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is an integer constant.  <a href="#a65923ae132fcc764357a8765878fb528">More...</a><br /></td></tr>
<tr class="separator:a65923ae132fcc764357a8765878fb528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b96c80ce43c8276e39c15787d997651"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5b96c80ce43c8276e39c15787d997651">is_const_number</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a5b96c80ce43c8276e39c15787d997651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is an integer/float constant.  <a href="#a5b96c80ce43c8276e39c15787d997651">More...</a><br /></td></tr>
<tr class="separator:a5b96c80ce43c8276e39c15787d997651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab432ffcc9fd4cb4fc0fd1891b141fb9f"><td class="memTemplParams" colspan="2">template&lt;typename FReduce &gt; </td></tr>
<tr class="memitem:ab432ffcc9fd4cb4fc0fd1891b141fb9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ab432ffcc9fd4cb4fc0fd1891b141fb9f">foldl</a> (FReduce freduce, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> init_value, const Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:ab432ffcc9fd4cb4fc0fd1891b141fb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left fold.  <a href="#ab432ffcc9fd4cb4fc0fd1891b141fb9f">More...</a><br /></td></tr>
<tr class="separator:ab432ffcc9fd4cb4fc0fd1891b141fb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a246623a4a0c9cd8f8a209ec952a8d1c3">is_const_power_of_two_integer</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x, int *shift)</td></tr>
<tr class="memdesc:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant power of two If x is power of two, write the power to the shift.  <a href="#a246623a4a0c9cd8f8a209ec952a8d1c3">More...</a><br /></td></tr>
<tr class="separator:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782dc226f8b2b537efdc56b1f76351d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a782dc226f8b2b537efdc56b1f76351d1">is_positive_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;a)</td></tr>
<tr class="separator:a782dc226f8b2b537efdc56b1f76351d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d552441331effb387b7c8fb241c454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a51d552441331effb387b7c8fb241c454">is_negative_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;a)</td></tr>
<tr class="separator:a51d552441331effb387b7c8fb241c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ca71170aca9d397c2125eb4f55c197"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:af2ca71170aca9d397c2125eb4f55c197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#af2ca71170aca9d397c2125eb4f55c197">MakeConstScalar</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, ValueType value)</td></tr>
<tr class="separator:af2ca71170aca9d397c2125eb4f55c197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1743e78389c4beaf0b788c631d424e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afb1743e78389c4beaf0b788c631d424e">TypeAnnotation</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype)</td></tr>
<tr class="memdesc:afb1743e78389c4beaf0b788c631d424e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a type annotation expression.  <a href="#afb1743e78389c4beaf0b788c631d424e">More...</a><br /></td></tr>
<tr class="separator:afb1743e78389c4beaf0b788c631d424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a98cd1a8440b18d6bac0ad3eaa42ed"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a12a98cd1a8440b18d6bac0ad3eaa42ed">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">ForType</a> for_type)</td></tr>
<tr class="separator:a12a98cd1a8440b18d6bac0ad3eaa42ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47050a2baf7e047f4994700ce8959d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a47050a2baf7e047f4994700ce8959d50">IRTransform</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;preorder, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;postorder, Optional&lt; Array&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt; only_enable=<a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a>)</td></tr>
<tr class="memdesc:a47050a2baf7e047f4994700ce8959d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir nodes in post DFS order, and transform it  <a href="#a47050a2baf7e047f4994700ce8959d50">More...</a><br /></td></tr>
<tr class="separator:a47050a2baf7e047f4994700ce8959d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5067fa233d111c9db9cc402ed599c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a4b5067fa233d111c9db9cc402ed599c3">PostOrderVisit</a> (const ObjectRef &amp;node, std::function&lt; void(const ObjectRef &amp;)&gt; fvisit)</td></tr>
<tr class="memdesc:a4b5067fa233d111c9db9cc402ed599c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once.  <a href="#a4b5067fa233d111c9db9cc402ed599c3">More...</a><br /></td></tr>
<tr class="separator:a4b5067fa233d111c9db9cc402ed599c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ae87f765e4d8230e3572428cdbe3e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a34ae87f765e4d8230e3572428cdbe3e1">Substitute</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, std::function&lt; Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; vmap)</td></tr>
<tr class="memdesc:a34ae87f765e4d8230e3572428cdbe3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap.  <a href="#a34ae87f765e4d8230e3572428cdbe3e1">More...</a><br /></td></tr>
<tr class="separator:a34ae87f765e4d8230e3572428cdbe3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc8d64e0d78149a19413953dec6230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a71cc8d64e0d78149a19413953dec6230">Substitute</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> expr, std::function&lt; Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt; vmap)</td></tr>
<tr class="memdesc:a71cc8d64e0d78149a19413953dec6230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified by vmap.  <a href="#a71cc8d64e0d78149a19413953dec6230">More...</a><br /></td></tr>
<tr class="separator:a71cc8d64e0d78149a19413953dec6230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2655d133d1c775d6b63298a65bc0cca2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2655d133d1c775d6b63298a65bc0cca2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2655d133d1c775d6b63298a65bc0cca2">Substitute</a> (T input, const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;value_map)</td></tr>
<tr class="memdesc:a2655d133d1c775d6b63298a65bc0cca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sugar for substitute via a given map.  <a href="#a2655d133d1c775d6b63298a65bc0cca2">More...</a><br /></td></tr>
<tr class="separator:a2655d133d1c775d6b63298a65bc0cca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5020900f638dead67cbeed15b478d6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5020900f638dead67cbeed15b478d6f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aa5020900f638dead67cbeed15b478d6f">Substitute</a> (T input, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;value_map)</td></tr>
<tr class="memdesc:aa5020900f638dead67cbeed15b478d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sugar for substitute via a given map.  <a href="#aa5020900f638dead67cbeed15b478d6f">More...</a><br /></td></tr>
<tr class="separator:aa5020900f638dead67cbeed15b478d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0fdee9fc81462318d59dbe64c8df26"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afc0fdee9fc81462318d59dbe64c8df26">IterVarType2String</a> (<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a> t)</td></tr>
<tr class="separator:afc0fdee9fc81462318d59dbe64c8df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="adb123be81447d2871f4c716ce2d1dc00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#adb123be81447d2871f4c716ce2d1dc00">tvm::tir::FloatImmNode</a> = typedef <a class="el" href="classtvm_1_1FloatImmNode.html">tvm::FloatImmNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8c7db788e840dc1c2ed1f365d5ea829"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ae8c7db788e840dc1c2ed1f365d5ea829">tvm::tir::IntImmNode</a> = typedef <a class="el" href="classtvm_1_1IntImmNode.html">tvm::IntImmNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8277e2a3d81a80a4776705673df51e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a8277e2a3d81a80a4776705673df51e0a">tvm::tir::Region</a> = typedef Array&lt;<a class="el" href="classtvm_1_1Range.html">Range</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a651e82a046f157a7d286b0985b3edb84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a651e82a046f157a7d286b0985b3edb84">tvm::tir::TCallEffectKind</a> = typedef <a class="el" href="classtvm_1_1Integer.html">Integer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use integer to record the kind. </p>

</div>
</div>
<a class="anchor" id="a0a81e48fe15eb305b96806e55e01a8c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a0a81e48fe15eb305b96806e55e01a8c1">tvm::tir::TGlobalSymbol</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global symbol of the op after lowering. </p>

</div>
</div>
<a class="anchor" id="a0c5d42cf669b8ceeb42aa13d95cb5262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a0c5d42cf669b8ceeb42aa13d95cb5262">tvm::tir::TVectorizable</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the op is overloaded for vector form. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a9ac05a14db42ca73da1d3945e7ce2fd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">tvm::tir::BufferType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39"></a>kDefault&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663"></a>kAutoBroadcast&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8f4a86b205145696c0555fd02bd37f46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">tvm::tir::CallEffectKind</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The effect type of the call. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8f4a86b205145696c0555fd02bd37f46a52c0b756f9ae7d0091ceb863a70e960b"></a>kExprAnnotation&#160;</td><td class="fielddoc">
<p>Function corresponds to an annotation(e.g. likely) and can translate to identity. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f4a86b205145696c0555fd02bd37f46a7ee78dd23fcf08988dfc48b55fce359a"></a>kPure&#160;</td><td class="fielddoc">
<p>Pure function that do not interacts with any external state. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f4a86b205145696c0555fd02bd37f46a8d8bb1cb393c8e093395350919eed4a7"></a>kReadState&#160;</td><td class="fielddoc">
<p>Function's that may read from states(e.g. RAM) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f4a86b205145696c0555fd02bd37f46af5cd553beea158407e669139955fffe0"></a>kUpdateState&#160;</td><td class="fielddoc">
<p>Function that may read/write from states(e.g. RAM). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc">
<p>Opaque function, cannot make any assumption. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f4a86b205145696c0555fd02bd37f46ac272fc9675a2a5836ff877d54427642b"></a>kSpecialCallArg&#160;</td><td class="fielddoc">
<p>Special intrinsic to annotate call arguments info only valid as a direct argument to a call. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8f4a86b205145696c0555fd02bd37f46a9d51682d02407dcdbbd4622cd54e4373"></a>kEmbedInfo&#160;</td><td class="fielddoc">
<p>Embed opaque information in the Expr, cannot be codegen. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aed067b57db2923a07913239b2165e019"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#aed067b57db2923a07913239b2165e019">tvm::tir::DeviceAPI</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">tvm::tir::ForType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional annotation of for loop. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493"></a>Serial&#160;</td><td class="fielddoc">
<p>serial execution. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc">
<p>parallel execution on CPU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725"></a>Vectorized&#160;</td><td class="fielddoc">
<p>Vector SIMD loop annotaion. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac"></a>Unrolled&#160;</td><td class="fielddoc">
<p>Unroll annotation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">tvm::tir::IterVarType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of iteration variable. Each <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> have a specific type. </p>
<p>The type of iter var can be overriden via stage.iter_var_attrs given they are compatible. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422"></a>kDataPar&#160;</td><td class="fielddoc">
<p>Data parallel iteration. This normally corresponds to axis of Tensor. Allow all <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> manipulations. </p>
<dl class="section note"><dt>Note</dt><dd>This does not mean the loop have to be executed in parallel fashion. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0"></a>kThreadIndex&#160;</td><td class="fielddoc">
<p>The <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> itself is a thread-index of a fixed thread launching group. Note that this is already assumed to be parallelized. </p>
<p>Disallow: split/fuse/vectorize/parallel </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4"></a>kCommReduce&#160;</td><td class="fielddoc">
<p>Communicative reduction. Cannot be directly parallelized. </p>
<p>Disallow: parallel/vectorize </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b"></a>kOrdered&#160;</td><td class="fielddoc">
<p>Serial loops with loop carry dependency, the iteration must execute in order. Cannot be re-ordered. </p>
<p>Disallow: reorder/parallel/vectorize </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c"></a>kOpaque&#160;</td><td class="fielddoc">
<p><a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> is opaque,. </p>
<p>May not corresponds to any generated loop Disallow all <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> manipulations and compute_at</p>
<dl class="section note"><dt>Note</dt><dd>This is usually used to implement composite op or external op, where the </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea338caebfc6f31586a1bdd09e3a67c9b5"></a>kOpaque&#160;</td><td class="fielddoc">
<p>Opaque function, cannot make any assumption. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403"></a>kUnrolled&#160;</td><td class="fielddoc">
<p>The execution is unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd"></a>kVectorized&#160;</td><td class="fielddoc">
<p>The loop is vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652"></a>kParallelized&#160;</td><td class="fielddoc">
<p>The loop is parallelized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47"></a>kTensorized&#160;</td><td class="fielddoc">
<p>Marks boundary of tensorization intrinsic. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acbe8f225faaf34c540194921a7ee6a66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t* tvm::tir::as_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get x as constant int expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address to the int expression, return nullptr, if x is not <a class="el" href="classtvm_1_1IntImm.html" title="Managed reference class to IntImmNode. ">IntImm</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abb777c4f4d61883c0cbdf9116458b70d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;K, V&gt; tvm::tir::as_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>dmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae11cb5c6f810546e5aa4e08a0684071a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::const_false </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a constant false expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanes</td><td>The number of lanes in the bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ac40c127b53bca09d4c39f806a98dfdf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::const_true </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a constant true expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanes</td><td>The number of lanes in the bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a95263c55bfbd2c439b8144f1d7a83bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> tvm::tir::decl_buffer </td>
          <td>(</td>
          <td class="paramtype">Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="classtvm_1_1runtime_1_1DataType.html#a237a714a6a16e14aa01fa4ac52426551">DataType::Float</a>(32)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;buffer&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new buffer given shape, and dtype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the buffer, </td></tr>
    <tr><td class="paramname">dtype</td><td>The content data type. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created buffer. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> for complete constructor. </dd></dl>

</div>
</div>
<a class="anchor" id="a095d1c3c1ce2dc66285ec1a1e4fbacec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::ExprUseVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *)&gt;&#160;</td>
          <td class="paramname"><em>vset_contains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether e expression used any var in variable set.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked. </td></tr>
    <tr><td class="paramname">vset_contains</td><td>The check function to see if var is in the vset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether e uses vset. </dd></dl>

</div>
</div>
<a class="anchor" id="a56573569b84c79678a7046a9500dbf73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::ExprUseVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether e expression used var. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked. </td></tr>
    <tr><td class="paramname">var</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether e uses v. </dd></dl>

</div>
</div>
<a class="anchor" id="ab432ffcc9fd4cb4fc0fd1891b141fb9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FReduce &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::foldl </td>
          <td>(</td>
          <td class="paramtype">FReduce&#160;</td>
          <td class="paramname"><em>freduce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>init_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left fold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freduce</td><td>The reduction function. </td></tr>
    <tr><td class="paramname">init_value</td><td>The initial value. </td></tr>
    <tr><td class="paramname">values</td><td>The values to be folded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FReduce</td><td>The type of the reduction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47050a2baf7e047f4994700ce8959d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::IRTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>preorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>postorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional&lt; Array&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>only_enable</em> = <code><a class="el" href="namespacetvm.html#aae7034e3e41c18e7fb78ff32bfc6a318">NullOpt</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir nodes in post DFS order, and transform it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The ir to be transformed. </td></tr>
    <tr><td class="paramname">preorder</td><td>The function called in before recursive mutation If preorder returns None, then the transform will proceed to recursive call. If preorder returns a not None Stmt/Expr, the transformer will simply return it and won't do further recursion. </td></tr>
    <tr><td class="paramname">postorder</td><td>The function called after recursive mutation. The recursive mutation result is passed to postorder for further mutation. </td></tr>
    <tr><td class="paramname">only_enable</td><td>List of <a class="el" href="classtvm_1_1runtime_1_1String.html" title="Reference to string objects. ">runtime::String</a>. If it is null, all IRNode will call preorder/postorder If it is not null, preorder/postorder will only be called when the IRNode's type key is in the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c414d5e54c099ad7287be302aac8f02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument </td></tr>
    <tr><td class="paramname">value</td><td>the value to be compared against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a65923ae132fcc764357a8765878fb528"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is an integer constant. </p>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant </dd></dl>

</div>
</div>
<a class="anchor" id="a5b96c80ce43c8276e39c15787d997651"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is an integer/float constant. </p>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant </dd></dl>

</div>
</div>
<a class="anchor" id="a246623a4a0c9cd8f8a209ec952a8d1c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether x is a constant power of two If x is power of two, write the power to the shift. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input expression. </td></tr>
    <tr><td class="paramname">shift</td><td>The output shift if x is power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant power of two </dd></dl>

</div>
</div>
<a class="anchor" id="a51d552441331effb387b7c8fb241c454"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8de8f843c6eb433b6ddfbf34e24099ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_no_op </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">tir::Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether stmt is nop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The input statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether stmt is nop </dd></dl>

</div>
</div>
<a class="anchor" id="a9b5104dcf0933da31329bb0b2580a947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant 1 </dd></dl>

</div>
</div>
<a class="anchor" id="a782dc226f8b2b537efdc56b1f76351d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a48bad3db162b334837716bf8e7ba9285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant 0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>

</div>
</div>
<a class="anchor" id="a48cd6ae7623f42cddbb05cc008c33711"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::IsPointerType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>element_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if type is a pointer to a runtime element type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to be checked. </td></tr>
    <tr><td class="paramname">element_type</td><td>The corresponding element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The check results </dd></dl>

</div>
</div>
<a class="anchor" id="afc0fdee9fc81462318d59dbe64c8df26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::tir::IterVarType2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ea566597880d04bd62fbec687e338b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename  = typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a const value with certain data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The target type. </td></tr>
    <tr><td class="paramname">value</td><td>The input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result expression. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The constant value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc4408508a413fb7f3b2567f8d847dbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a const zero expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result expression. </dd></dl>

</div>
</div>
<a class="anchor" id="af2ca71170aca9d397c2125eb4f55c197"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::MakeConstScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12a98cd1a8440b18d6bac0ad3eaa42ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::tir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">ForType</a>&#160;</td>
          <td class="paramname"><em>for_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4b5067fa233d111c9db9cc402ed599c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const ObjectRef &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const ObjectRef &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb03afda344eb4d3a5d2d3fd4e1d266d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1tir.html#a8f4a86b205145696c0555fd02bd37f46">CallEffectKind</a> tvm::tir::SideEffect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze the side effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CallEffectKind, can be kPure, kReadState or kUpdateState </dd></dl>

</div>
</div>
<a class="anchor" id="a34ae87f765e4d8230e3572428cdbe3e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a class="anchor" id="a71cc8d64e0d78149a19413953dec6230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; Optional&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;(const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;var)&gt;&#160;</td>
          <td class="paramname"><em>vmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified by vmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">vmap</td><td>returns a new value if re-mapping is needed, otherwise returns nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>

</div>
</div>
<a class="anchor" id="a2655d133d1c775d6b63298a65bc0cca2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sugar for substitute via a given map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to be updated. </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input type, can be <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> or <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5020900f638dead67cbeed15b478d6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sugar for substitute via a given map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input to be updated. </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input type, can be <a class="el" href="classtvm_1_1PrimExpr.html" title="Reference to PrimExprNode. ">PrimExpr</a> or <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb1743e78389c4beaf0b788c631d424e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::TypeAnnotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a type annotation expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expr a expression with dtype. </dd></dl>

</div>
</div>
<a class="anchor" id="ae110e02855d8bc12eb8b6f92ed391844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&gt; tvm::tir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>defs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The function to be checked. </td></tr>
    <tr><td class="paramname">defs</td><td>The vars that is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of undefined vars. </dd></dl>

</div>
</div>
<a class="anchor" id="a99de316b20c7af2e8b4f06773ee69a5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&gt; tvm::tir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of undefined vars. </dd></dl>

</div>
</div>
<a class="anchor" id="a53dfcb6ef7e178a83fda0bbb5dddcb39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyGPUCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be checked </td></tr>
    <tr><td class="paramname">constraints</td><td>The dict to specify constraints to check. Possible keys are</td></tr>
  </table>
  </dd>
</dl>
<p>"max_local_memory_per_block": Total amount of local memory per block (in bytes). "max_shared_memory_per_block": Total amount of shared memory per block (in bytes). "max_threads_per_block": Maximum number of threads per block. "max_thread_x": Maximum length of threadIdx.x. "max_thread_y": Maximum length of threadIdx.y. "max_thread_z": Maximum length of threadIdx.z.</p>
<p>If one key is missing in this argument, the pass won't check for that item. </p><dl class="section return"><dt>Returns</dt><dd>valid Whether it is a valid GPU code </dd></dl>

</div>
</div>
<a class="anchor" id="ac69bcf127843e5e671379e44ab47ca27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if memory accesses are legal for a specific target device type. </p>
<p>In the case that tgt is cuda, if not all workload is bound with threads, CPU code is generated that tries to access GPU memory, which is illegal. This pass performs verification for this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be verified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success of memory verification. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b38edd60b6ff952cefb74842a8ae826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifySSA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies whether the IR stmt or Expr is in SSA form. That is: each <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TIR ">Var</a> is defined and assigned once(in Let/For) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be verified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether IR is in SSA form.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All passes in TIR consume and produce SSA form. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
