<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::auto_scheduler::State Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1auto__scheduler.html">auto_scheduler</a></li><li class="navelem"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtvm_1_1auto__scheduler_1_1State-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::auto_scheduler::State Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html" title="A state in the search process. It consists of the current loop structure and a list of transformation...">StateNode</a>.  
 <a href="classtvm_1_1auto__scheduler_1_1State.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="loop__state_8h_source.html">loop_state.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::auto_scheduler::State:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1auto__scheduler_1_1State__inherit__graph.svg" width="164" height="375"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::auto_scheduler::State:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1auto__scheduler_1_1State__coll__graph.svg" width="164" height="375"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e8198b1f51b42cfbbee4b9f42160749"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a9e8198b1f51b42cfbbee4b9f42160749">State</a> (const Array&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">te::Operation</a> &gt; &amp;ops)</td></tr>
<tr class="memdesc:a9e8198b1f51b42cfbbee4b9f42160749"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor.  <a href="#a9e8198b1f51b42cfbbee4b9f42160749">More...</a><br /></td></tr>
<tr class="separator:a9e8198b1f51b42cfbbee4b9f42160749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8038c6735f2f522242db2e08b6541d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a8038c6735f2f522242db2e08b6541d01">ToStr</a> (bool delete_trivial_loop=true) const </td></tr>
<tr class="memdesc:a8038c6735f2f522242db2e08b6541d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the state to a human readable string.  <a href="#a8038c6735f2f522242db2e08b6541d01">More...</a><br /></td></tr>
<tr class="separator:a8038c6735f2f522242db2e08b6541d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad750c2a82ffe45d50f4b12530e8dafbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#ad750c2a82ffe45d50f4b12530e8dafbe">ApplySteps</a> (const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;dag)</td></tr>
<tr class="memdesc:ad750c2a82ffe45d50f4b12530e8dafbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">General call step functions with a runtime dynamic dispatcher. This will re-apply all the transform steps from the initial state.  <a href="#ad750c2a82ffe45d50f4b12530e8dafbe">More...</a><br /></td></tr>
<tr class="separator:ad750c2a82ffe45d50f4b12530e8dafbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4bbe8e149a2ac418b3be72054b0649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#afe4bbe8e149a2ac418b3be72054b0649">bind</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, <a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ec">IteratorAnnotation</a> thread_type)</td></tr>
<tr class="memdesc:afe4bbe8e149a2ac418b3be72054b0649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#aa9ace0034447b461610ebc1c2de69a26" title="Bind the IterVar to thread index. ">te::Stage::bind</a></code>.  <a href="#afe4bbe8e149a2ac418b3be72054b0649">More...</a><br /></td></tr>
<tr class="separator:afe4bbe8e149a2ac418b3be72054b0649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2376f0180bc5b5dd4b456f2a75d4a366"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a2376f0180bc5b5dd4b456f2a75d4a366">parallel</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a2376f0180bc5b5dd4b456f2a75d4a366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a60a6be10a1a96cb594c1399efabafef3" title="Parallelize iteration. ">te::Stage::parallel</a></code>.  <a href="#a2376f0180bc5b5dd4b456f2a75d4a366">More...</a><br /></td></tr>
<tr class="separator:a2376f0180bc5b5dd4b456f2a75d4a366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a9d2e226bae38a36e4be4af1d1ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#aa68a9d2e226bae38a36e4be4af1d1ae4">unroll</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, int max_unroll=-1)</td></tr>
<tr class="memdesc:aa68a9d2e226bae38a36e4be4af1d1ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#af83ad8672660403504f472228b044b33" title="Unroll iteration. ">te::Stage::unroll</a></code>.  <a href="#aa68a9d2e226bae38a36e4be4af1d1ae4">More...</a><br /></td></tr>
<tr class="separator:aa68a9d2e226bae38a36e4be4af1d1ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b8a21210d63bea241dbab085d89b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a97b8a21210d63bea241dbab085d89b53">vectorize</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it)</td></tr>
<tr class="memdesc:a97b8a21210d63bea241dbab085d89b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a44d33e3920106e75dc7c68272f880812" title="Vectorize iteration. ">te::Stage::vectorize</a></code>.  <a href="#a97b8a21210d63bea241dbab085d89b53">More...</a><br /></td></tr>
<tr class="separator:a97b8a21210d63bea241dbab085d89b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76198c368b38ad64eefa45a3147aa6ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a76198c368b38ad64eefa45a3147aa6ac">fuse</a> (int stage_id, const Array&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt; &amp;iters)</td></tr>
<tr class="memdesc:a76198c368b38ad64eefa45a3147aa6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a5658065d9cbbee620bbd107d30c4ae72" title="Fuse the inner outer domain to the target. ">te::Stage::fuse</a></code>.  <a href="#a76198c368b38ad64eefa45a3147aa6ac">More...</a><br /></td></tr>
<tr class="separator:a76198c368b38ad64eefa45a3147aa6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e95966b46977eff629a5f4f1564533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a16e95966b46977eff629a5f4f1564533">reorder</a> (int stage_id, const Array&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt; &amp;order)</td></tr>
<tr class="memdesc:a16e95966b46977eff629a5f4f1564533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#ad96cd240a92df9cafae89cdf2a7e302e" title="Reorder the iteration. ">te::Stage::reorder</a></code>.  <a href="#a16e95966b46977eff629a5f4f1564533">More...</a><br /></td></tr>
<tr class="separator:a16e95966b46977eff629a5f4f1564533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5815f21fc90ba7cc379c2410c05ab54c"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a5815f21fc90ba7cc379c2410c05ab54c">split</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, const Array&lt; Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; &amp;lengths, bool inner_to_outer=true)</td></tr>
<tr class="memdesc:a5815f21fc90ba7cc379c2410c05ab54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a5a7cd562be59b68a187ad97085a3425d" title="Split the parent by factor, generate. ">te::Stage::split</a></code>.  <a href="#a5815f21fc90ba7cc379c2410c05ab54c">More...</a><br /></td></tr>
<tr class="separator:a5815f21fc90ba7cc379c2410c05ab54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd6d26db25a42427d6fb51b3717effc"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a3cd6d26db25a42427d6fb51b3717effc">follow_split</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, int src_step_id, int n_split)</td></tr>
<tr class="memdesc:a3cd6d26db25a42427d6fb51b3717effc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive extends to split step.  <a href="#a3cd6d26db25a42427d6fb51b3717effc">More...</a><br /></td></tr>
<tr class="separator:a3cd6d26db25a42427d6fb51b3717effc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d72cbcaa97f157076e98ed30a9f477"><td class="memItemLeft" align="right" valign="top">Array&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a26d72cbcaa97f157076e98ed30a9f477">follow_fused_split</a> (int stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;it, const Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;src_step_ids, int level, bool factor_or_nparts)</td></tr>
<tr class="memdesc:a26d72cbcaa97f157076e98ed30a9f477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive extends to split step.  <a href="#a26d72cbcaa97f157076e98ed30a9f477">More...</a><br /></td></tr>
<tr class="separator:a26d72cbcaa97f157076e98ed30a9f477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e00bb2f70dc2e28c236c92a14204850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a0e00bb2f70dc2e28c236c92a14204850">compute_at</a> (int stage_id, int target_stage_id, const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;target_iter)</td></tr>
<tr class="memdesc:a0e00bb2f70dc2e28c236c92a14204850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a071545484de7a894c01ccf0e77183730" title="specify the schedule to be computed at the parent schedule&#39;s scope. ">te::Stage::compute_at</a></code>.  <a href="#a0e00bb2f70dc2e28c236c92a14204850">More...</a><br /></td></tr>
<tr class="separator:a0e00bb2f70dc2e28c236c92a14204850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa383a9b40e490c131ed696d696c3c7a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#aa383a9b40e490c131ed696d696c3c7a0">compute_inline</a> (int stage_id)</td></tr>
<tr class="memdesc:aa383a9b40e490c131ed696d696c3c7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a1c58b35e37561739440b322c29d30c3b" title="Compute the function inline. ">te::Stage::compute_inline</a></code>.  <a href="#aa383a9b40e490c131ed696d696c3c7a0">More...</a><br /></td></tr>
<tr class="separator:aa383a9b40e490c131ed696d696c3c7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b192456798daac7d5b8403c1215d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a6a0b192456798daac7d5b8403c1215d8">compute_root</a> (int stage_id)</td></tr>
<tr class="memdesc:a6a0b192456798daac7d5b8403c1215d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a95b58b2d2ec034ecd0bdb99f95c0b0ba" title="Compute the function at group root. ">te::Stage::compute_root</a></code>.  <a href="#a6a0b192456798daac7d5b8403c1215d8">More...</a><br /></td></tr>
<tr class="separator:a6a0b192456798daac7d5b8403c1215d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff71b692f0eabfabf515ed91b59a116"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a4ff71b692f0eabfabf515ed91b59a116">cache_read</a> (int stage_id, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;scope_name, const Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;reader_stage_ids, const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;dag)</td></tr>
<tr class="memdesc:a4ff71b692f0eabfabf515ed91b59a116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#a38ef95a62faf0c15f132847efa20249b" title="create a cache read of original tensor for readers. This will mutate the body of the readers...">te::Schedule::cache_read</a></code>.  <a href="#a4ff71b692f0eabfabf515ed91b59a116">More...</a><br /></td></tr>
<tr class="separator:a4ff71b692f0eabfabf515ed91b59a116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385adc36d7cb242e8204fe14c4df8335"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#a385adc36d7cb242e8204fe14c4df8335">cache_write</a> (int stage_id, const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;scope_name, const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;dag)</td></tr>
<tr class="memdesc:a385adc36d7cb242e8204fe14c4df8335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#ada9825f59ef130a0ab0b3a01ea348d71" title="Create a cache write tensor for producing tensor. The the tensor will take over body of original tens...">te::Schedule::cache_write</a></code>.  <a href="#a385adc36d7cb242e8204fe14c4df8335">More...</a><br /></td></tr>
<tr class="separator:a385adc36d7cb242e8204fe14c4df8335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31c450ae9eb4fac98974d0de647575f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#af31c450ae9eb4fac98974d0de647575f">TVM_DEFINE_OBJECT_REF_METHODS</a> (<a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a>, ObjectRef, <a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a>)</td></tr>
<tr class="separator:af31c450ae9eb4fac98974d0de647575f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea500365cb7a964a21ac1677fc29fc99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html#aea500365cb7a964a21ac1677fc29fc99">TVM_DEFINE_OBJECT_REF_COW_METHOD</a> (<a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a>)</td></tr>
<tr class="separator:aea500365cb7a964a21ac1677fc29fc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Managed reference to <a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html" title="A state in the search process. It consists of the current loop structure and a list of transformation...">StateNode</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html" title="A state in the search process. It consists of the current loop structure and a list of transformation...">StateNode</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9e8198b1f51b42cfbbee4b9f42160749"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tvm::auto_scheduler::State::State </td>
          <td>(</td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1te_1_1Operation.html">te::Operation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td><code><a class="el" href="classtvm_1_1te_1_1Operation.html" title="Operation that produces tensors. ">te::Operation</a></code>s for a compute declaration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad750c2a82ffe45d50f4b12530e8dafbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::ApplySteps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;&#160;</td>
          <td class="paramname"><em>dag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General call step functions with a runtime dynamic dispatcher. This will re-apply all the transform steps from the initial state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dag</td><td>The original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> of this state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The input <code>dag</code> is different from the class member <code>current_compute_dag</code>. This function takes the initial <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> as input to replay all the history. While the <code>current_compute_dag</code> is used to track the current stage status, for some transform step may change the op stage structure. </dd></dl>

</div>
</div>
<a class="anchor" id="afe4bbe8e149a2ac418b3be72054b0649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1auto__scheduler.html#ad81bc395fc88957fbd33bf041adbe0ec">IteratorAnnotation</a>&#160;</td>
          <td class="paramname"><em>thread_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#aa9ace0034447b461610ebc1c2de69a26" title="Bind the IterVar to thread index. ">te::Stage::bind</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be binded. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be binded. </td></tr>
    <tr><td class="paramname">thread_type</td><td>The thread type to be binded. We dirctly use the IteratorAnnotation as this input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator result after binded. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ff71b692f0eabfabf515ed91b59a116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::auto_scheduler::State::cache_read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>scope_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reader_stage_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;&#160;</td>
          <td class="paramname"><em>dag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#a38ef95a62faf0c15f132847efa20249b" title="create a cache read of original tensor for readers. This will mutate the body of the readers...">te::Schedule::cache_read</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be cache read. </td></tr>
    <tr><td class="paramname">scope_name</td><td>The scope name of the newly added read stage. </td></tr>
    <tr><td class="paramname">reader_stage_ids</td><td>The indices of read stages. </td></tr>
    <tr><td class="paramname">dag</td><td>The original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> of this state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Cache read step will add an extra stage to the original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> (at the back of the target stage), a up-to-date <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> is stored in <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a>'s <code>current_compute_dag</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a385adc36d7cb242e8204fe14c4df8335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::auto_scheduler::State::cache_write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>scope_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html">ComputeDAG</a> &amp;&#160;</td>
          <td class="paramname"><em>dag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Schedule.html#ada9825f59ef130a0ab0b3a01ea348d71" title="Create a cache write tensor for producing tensor. The the tensor will take over body of original tens...">te::Schedule::cache_write</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be cache write. </td></tr>
    <tr><td class="paramname">scope_name</td><td>The scope name of the newly added compute stage. </td></tr>
    <tr><td class="paramname">dag</td><td>The original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> of this state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Cache write step will add an extra stage to the original <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> (in the front of the target stage), a up-to-date <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html" title="Managed reference to ComputeDAGNode. ">ComputeDAG</a> is stored in <a class="el" href="classtvm_1_1auto__scheduler_1_1State.html" title="Managed reference to StateNode. ">State</a>'s <code>current_compute_dag</code>. This step will cache write all output tensors of the target stage. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e00bb2f70dc2e28c236c92a14204850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::compute_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>target_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a071545484de7a894c01ccf0e77183730" title="specify the schedule to be computed at the parent schedule&#39;s scope. ">te::Stage::compute_at</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be computed at. </td></tr>
    <tr><td class="paramname">target_stage_id</td><td>The index of stage that this step will compute at to. </td></tr>
    <tr><td class="paramname">target_iter</td><td>The iterator in target stage that this step will compute at to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After compute_at, we need careful dependency analysis to compute the accurate bound information. However, it is relatively expensive and complicated, so we just fill "None" as bound for the newly created iterators. Call <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html#a6438e7f150837e2245824524c0b8982e" title="Fill the correct bound information for a given state by calling ir_pass::InferBound. The states can lose complete bound information after some transform steps (e.g., compute_at). We can call this function to infer and fill all the bound information. This function calls TVM InferBound pass internally to get the bound. The returned state of this function is guaranteed to have complete bound information. ">ComputeDAG::InferBound</a> on the updated state to get the complete bound information. </dd></dl>

</div>
</div>
<a class="anchor" id="aa383a9b40e490c131ed696d696c3c7a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::compute_inline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a1c58b35e37561739440b322c29d30c3b" title="Compute the function inline. ">te::Stage::compute_inline</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be marked compute inlined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a0b192456798daac7d5b8403c1215d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::compute_root </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a95b58b2d2ec034ecd0bdb99f95c0b0ba" title="Compute the function at group root. ">te::Stage::compute_root</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be marked compute at root. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After compute_root, we need careful dependency analysis to compute the accurate bound information. However, it is relatively expensive and complicated, so we just fill "None" as bound for the newly created iterators. Call <a class="el" href="classtvm_1_1auto__scheduler_1_1ComputeDAG.html#a6438e7f150837e2245824524c0b8982e" title="Fill the correct bound information for a given state by calling ir_pass::InferBound. The states can lose complete bound information after some transform steps (e.g., compute_at). We can call this function to infer and fill all the bound information. This function calls TVM InferBound pass internally to get the bound. The returned state of this function is guaranteed to have complete bound information. ">ComputeDAG::InferBound</a> on the updated state to get the complete bound information. </dd></dl>

</div>
</div>
<a class="anchor" id="a26d72cbcaa97f157076e98ed30a9f477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&gt; tvm::auto_scheduler::State::follow_fused_split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_step_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>factor_or_nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive extends to split step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be split. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be split. </td></tr>
    <tr><td class="paramname">src_step_ids</td><td>The indices of the split steps to be followed in the history. </td></tr>
    <tr><td class="paramname">level</td><td>Use the length in this split level. </td></tr>
    <tr><td class="paramname">factor_or_nparts</td><td>True to use <code>factor</code> for split from inner to outer, False to use <code>nparts</code> for split from outer to inner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The splitted new Iterators. </dd></dl>

</div>
</div>
<a class="anchor" id="a3cd6d26db25a42427d6fb51b3717effc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&gt; tvm::auto_scheduler::State::follow_split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src_step_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive extends to split step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be split. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be split. </td></tr>
    <tr><td class="paramname">src_step_id</td><td>The index of the split step to be followed in the history. </td></tr>
    <tr><td class="paramname">n_split</td><td>The number of split level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The splitted new Iterators. </dd></dl>

</div>
</div>
<a class="anchor" id="a76198c368b38ad64eefa45a3147aa6ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::fuse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>iters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a5658065d9cbbee620bbd107d30c4ae72" title="Fuse the inner outer domain to the target. ">te::Stage::fuse</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be fused. </td></tr>
    <tr><td class="paramname">iters</td><td>The iterators to be fused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator result after fuse. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the iterators to be fused have stages attached at them(by compute_at), the fused result will become the new attach point. </dd></dl>

</div>
</div>
<a class="anchor" id="a2376f0180bc5b5dd4b456f2a75d4a366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::parallel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a60a6be10a1a96cb594c1399efabafef3" title="Parallelize iteration. ">te::Stage::parallel</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be paralleled. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be paralleled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator result after parallel. </dd></dl>

</div>
</div>
<a class="anchor" id="a16e95966b46977eff629a5f4f1564533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::auto_scheduler::State::reorder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#ad96cd240a92df9cafae89cdf2a7e302e" title="Reorder the iteration. ">te::Stage::reorder</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be reordered. </td></tr>
    <tr><td class="paramname">order</td><td>The expected iterator order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5815f21fc90ba7cc379c2410c05ab54c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;<a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a>&gt; tvm::auto_scheduler::State::split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array&lt; Optional&lt; <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inner_to_outer</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a5a7cd562be59b68a187ad97085a3425d" title="Split the parent by factor, generate. ">te::Stage::split</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be split. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be split. </td></tr>
    <tr><td class="paramname">lengths</td><td>The multiple split factors. Can be None to be filled by search policy. </td></tr>
    <tr><td class="paramname">inner_to_outer</td><td>Whether the factor go from inner to outer, or from outer to inner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator results after split. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If we do split on an iterator which has stages attached at it(by compute_at), the inner most iterator of split results will become the new attach point. </dd></dl>

</div>
</div>
<a class="anchor" id="a8038c6735f2f522242db2e08b6541d01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a> tvm::auto_scheduler::State::ToStr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_trivial_loop</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the state to a human readable string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delete_trivial_loop</td><td>True for skipping the trivial loops. (undefined or extent == 1, default set to True) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The human readable state structure. </dd></dl>

</div>
</div>
<a class="anchor" id="aea500365cb7a964a21ac1677fc29fc99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::auto_scheduler::State::TVM_DEFINE_OBJECT_REF_COW_METHOD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af31c450ae9eb4fac98974d0de647575f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tvm::auto_scheduler::State::TVM_DEFINE_OBJECT_REF_METHODS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1State.html">State</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectRef&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1auto__scheduler_1_1StateNode.html">StateNode</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa68a9d2e226bae38a36e4be4af1d1ae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::unroll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_unroll</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#af83ad8672660403504f472228b044b33" title="Unroll iteration. ">te::Stage::unroll</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be unrolled. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be unrolled. </td></tr>
    <tr><td class="paramname">max_unroll</td><td>The max unroll limit. <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html" title="Managed reference to IteratorNode. ">Iterator</a> with extent larger than this limit will be skipped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator result after unrolled. </dd></dl>

</div>
</div>
<a class="anchor" id="a97b8a21210d63bea241dbab085d89b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> tvm::auto_scheduler::State::vectorize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stage_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1auto__scheduler_1_1Iterator.html">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule primitive corresponds to <code><a class="el" href="classtvm_1_1te_1_1Stage.html#a44d33e3920106e75dc7c68272f880812" title="Vectorize iteration. ">te::Stage::vectorize</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stage_id</td><td>The index of the stage to be vectorized. </td></tr>
    <tr><td class="paramname">it</td><td>The iterator to be vectorized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator result after vectorize. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/auto_scheduler/<a class="el" href="loop__state_8h_source.html">loop_state.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
